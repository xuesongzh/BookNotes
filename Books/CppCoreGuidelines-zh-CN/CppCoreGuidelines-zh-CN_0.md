# <a name="main"></a>C++ 核心指导方针

2019/12/8


编辑：

* [Bjarne Stroustrup](http://www.stroustrup.com)
* [Herb Sutter](http://herbsutter.com/)

翻译：

* 李一楠 (li_yinan AT 163 DOT com)

本文档是处于持续改进之中的在线文档。
本文档作为开源项目，发布版本为 0.8。
复制，使用，修改，以及创建本项目的衍生物，受到一份 MIT 风格的版权授权。
向本项目作出贡献需要同意一份贡献者授权。详情参见附属的 [LICENSE](LICENSE) 文件。
我们将本项目开放给"友好用户"进行使用，复制，修改，以及生产衍生物，并希望能够获得建设性的资源投入。

十分欢迎大家提出意见和改进建议。
随着我们的知识增长，随着语言和可用的程序库的改进，我们计划对这份文档不断进行修改和扩充。
当提出您的意见时，请关注[导言](#S-introduction)部分，其中概述了我们的目标和所采用的一般方法。
贡献者的列表请参见[这里](#SS-ack)。

已知问题：

* 仍未对规则集合的完整性、一致性和可强制实施性加以全面的检查。
* 三问号 (???) 用于标记已知的信息缺失。
* 需要更新参考部分；许多前 C++11 的源代码都过于老旧。
* [To-do: 未分类的规则原型](#S-unclassified) 是一份基本上保持最新状态的 to-do 列表。

您可以[阅读本指南的范围和结构的说明](#S-abstract)，或者直接跳转到：

* [In: 导言](#S-introduction)
* [P: 理念](#S-philosophy)
* [I: 接口](#S-interfaces)
* [F: 函数](#S-functions)
* [C: 类和类层次](#S-class)
* [Enum: 枚举](#S-enum)
* [R: 资源管理](#S-resource)
* [ES: 表达式和语句](#S-expr)
* [Per: 性能](#S-performance)
* [CP: 并发与并行](#S-concurrency)
* [E: 错误处理](#S-errors)
* [Con: 常量和不可变性](#S-const)
* [T: 模板和泛型编程](#S-templates)
* [CPL: C 风格的编程](#S-cpl)
* [SF: 源文件](#S-source)
* [SL: 标准库](#S-stdlib)

配套章节：

* [A: 架构相关理念](#S-A)
* [NR: 伪规则和错误的看法](#S-not)
* [RF: 参考资料](#S-references)
* [PRO: 剖面配置](#S-profile)
* [GSL: 指导方针支持库](#S-gsl)
* [NL: 命名和代码布局规则](#S-naming)
* [FAQ: 常见问题的解答](#S-faq)
* [附录 A: 程序库](#S-libraries)
* [附录 B: 代码的现代化转换](#S-modernizing)
* [附录 C: 相关讨论](#S-discussion)
* [附录 D: 支持工具](#S-tools)
* [词汇表](#S-glossary)
* [To-do: 未分类的规则原型](#S-unclassified)

您可以查看有关某个具体的语言特性的一些规则：

* 赋值：
[正规类型](#Rc-regular) --
[优先采用初始化](#Rc-initialize) --
[复制](#Rc-copy-semantic) --
[移动](#Rc-move-semantic) --
[以及其他操作](#Rc-matched) --
[缺省操作](#Rc-eqdefault)
* `class`：
[数据](#Rc-org) --
[不变式](#Rc-struct) --
[成员](#Rc-member) --
[辅助函数](#Rc-helper) --
[具体类型](#SS-concrete) --
[构造函数，=，和析构函数](#S-ctor) --
[类层次](#SS-hier) --
[运算符](#SS-overload)
* `concept`：
[规则](#SS-concepts) --
[泛型编程中](#Rt-raise) --
[模板实参](#Rt-concepts) --
[语义](#Rt-low)
* 构造函数：
[不变式](#Rc-struct) --
[建立不变式](#Rc-ctor) --
[`throw`](#Rc-throw) --
[缺省操作](#Rc-default0) --
[不需要](#Rc-default) --
[`explicit`](#Rc-explicit) --
[委派](#Rc-delegating) --
[`virtual`](#Rc-ctor-virtual)
* 派生 `class`：
[何时使用](#Rh-domain) --
[作为接口](#Rh-abstract) --
[析构函数](#Rh-dtor) --
[复制](#Rh-copy) --
[取值和设值](#Rh-get) --
[多继承](#Rh-mi-interface) --
[重载](#Rh-using) --
[分片](#Rc-copy-virtual) --
[`dynamic_cast`](#Rh-dynamic_cast)
* 析构函数：
[以及构造函数](#Rc-matched) --
[何时需要？](#Rc-dtor) --
[不可失败](#Rc-dtor-fail)
* 异常：
[错误](#S-errors) --
[`throw`](#Re-throw) --
[仅用于错误](#Re-errors) --
[`noexcept`](#Re-noexcept) --
[最少化 `try`](#Re-catch) --
[无异常如何？](#Re-no-throw-codes)
* `for`：
[范围式 `for` 和 `for`](#Res-for-range) --
[`for` 和 `while`](#Res-for-while) --
[`for`-初始化式](#Res-for-init) --
[空循环体](#Res-empty) --
[循环变量](#Res-loop-counter) --
[循环变量的类型 ???](#Res-???)
* 函数：
[命名](#Rf-package) --
[单操作](#Rf-logical) --
[不能抛出异常](#Rf-noexcept) --
[实参](#Rf-smart) --
[实参传递](#Rf-conventional) --
[多返回值](#Rf-out-multi) --
[指针](#Rf-return-ptr) --
[lambda](#Rf-capture-vs-overload)
* `inline`:
[小型函数](#Rf-inline) --
[头文件中](#Rs-inline)
* 初始化：
[总是](#Res-always) --
[优先采用 `{}`](#Res-list) --
[lambda](#Res-lambda-init) --
[类内初始化式](#Rc-in-class-initializer) --
[类成员](#Rc-initialize) --
[工厂函数](#Rc-factory)
* lambda 表达式：
[何时使用](#SS-lambdas)
* 运算符：
[约定](#Ro-conventional) --
[避免转换运算符](#Ro-conversion) --
[与 lambda](#Ro-lambda)
* `public`, `private`, 和 `protected`：
[信息隐藏](#Rc-private) --
[一致性](#Rh-public) --
[`protected`](#Rh-protected)
* `static_assert`：
[编译时检查](#Rp-compile-time) --
[和概念](#Rt-check-class)
* `struct`：
[用于组织数据](#Rc-org) --
[没有不变式时使用](#Rc-struct) --
[不能有私有成员](#Rc-class)
* `template`：
[抽象](#Rt-raise) --
[容器](#Rt-cont) --
[概念](#Rt-concepts)
* `unsigned`：
[和 `signed`](#Res-mix) --
[位操作](#Res-unsigned)
* `virtual`：
[接口](#Ri-abstract) --
[非 `virtual`](#Rc-concrete) --
[析构函数](#Rc-dtor-virtual) --
[不能失败](#Rc-dtor-fail)

您可以查看用于表达这些规则的一些设计概念：

* 断言：???
* 错误：???
* 异常：异常保证 (???)
* 故障：???
* 不变式：???
* 泄漏：???
* 程序库：???
* 前条件：???
* 后条件：???
* 资源：???

# <a name="S-abstract"></a>概要

本文档是一组有关如何更好使用 C++ 的指导方针的集合。
本文档的目标是帮助人们更有效地使用现代 C++。
所谓"现代"的含义是指有效使用 ISO C++ 标准（目前是 C++17，但几乎所有的推荐也适用于 C++14 和 C++11）。
换句话说，如果你从现在开始算起，五年后你的代码看起来是怎么样的？十年呢？

这些指导方针所关注的是一些**相对高层次的问题**，比如**接口，资源管理，内存管理，以及并发**等等。
**这样的规则会对应用的架构，以及程序库的设计都造成影响**。
如果遵循这些规则，代码将会是静态类型安全的，没有资源泄露，并且能够捕捉到比当今的代码通常所能捕捉到的多得多的编程逻辑错误。
还能更快速地运行——你不必牺牲程序的正确性。

我们对于如命名约定和缩进风格一类的低层次的问题不那么关注。
当然，对程序员有帮助的任何话题都是可接受的。

我们最初的规则集合强调的是（各种形式的）安全性以及简单性。
它们有些过于严格了。
我们预期将会引入更多的例外情况， 以便使它们更好地适应现实世界的需要。
我们也需要更多的规则。

您可能会发现，有的规则与您的预期相反，甚至是与您的经验相违背。
其实如果我们没建议您在任何方面改变您的编码风格，那其实就是我们的失败！
请您尝试验证或者证伪这些规则吧！
尤其是，我们十分期望让一些规则能够建立在真实的测量数据上，或者是一些更好的例子之上。

您可能会觉得一些规则很显然，甚至没有什么价值。
但请记住，指导方针的目的之一就在于**帮助那些经验不足的，或来自其他背景或使用其他语言的人，能够迅速行动起来。**

这里的许多规则有意设计成可以由分析工具提供支持的。
违反规则的代码会打上标记，以引用（或者链接）到相关的规则。
您在开始编码前并不需要记住所有这些规则。
一种看待这些指导方针的方式，是一份恰好可以让人类读懂的针对这些工具的规范文件。

这些规则都是为了逐步引入一个代码库而设计的。
我们计划建立这样的工具，并希望其他人也能提供它们。

十分欢迎大家提出意见和改进建议。
随着我们的知识增长，随着语言和可用的程序库的改进，我们计划对这份文档不断进行修改和扩充。

# <a name="S-introduction"></a>In: 导言

本文档是一组核心指导方针，针对现代 C++（C++17，C++14 和 C++11），还考虑到了语言将来有希望的增强，以及 ISO 技术规范（TSs）。
其目标是帮助 C++ 程序员编写更简单、更高效、更加可维护的代码。

导言概览：

* [In.target: 目标读者](#SS-readers)
* [In.aims: 目标](#SS-aims)
* [In.not: 非目标](#SS-non)
* [In.force: 强制实施](#SS-force)
* [In.struct: 本文档的结构](#SS-struct)
* [In.sec: 主要章节](#SS-sec)

## <a name="SS-readers"></a>In.target: 目标读者

所有 C++ 程序员。其中也包括[考虑采用 C 语言的程序员](#S-cpl)。

## <a name="SS-aims"></a>In.aims: 目标

本文档的目标是帮助开发者采用现代 C++（目前是 C++17），并在各个代码库之间达成更加统一的编码风格。

我们并不妄想这些规则中的每一条都能有效地在任何代码库中进行实施。对老旧系统进行升级是很困难的。不过我们确实认为，采纳了一条规则的程序总会比不这样做的程序更加不易出错也更加便于维护。通常，采用规则也会带来更快速或更容易的初始开发活动。
**就我们所能说的，这些规则能够使得代码的性能，相对于更传统的技术来说同样好甚至更好**；它们都是依照零开销原则设立的——"**不使用就没有负担**"（"what you don't use, you don't pay for"）或"当恰当地使用抽象机制时，所得的性能至少与使用低级语言构造手工编码的结果一样好"。
我们认为这些规则对新代码来说是理想的，也有很多机会在老代码中实施，并试图尽可能接近并灵活地对这些理想情况进行近似。
请记住：

### <a name="R0"></a>In.0: 不要慌张！

请花些时间理解一下指南规则对你的程序能够造成的影响。

这些指导方针都是遵循"超集的子集"原则（[Stroustrup05](#Stroustrup05)）而设计的。
它们并非仅仅定义了 C++ 的一个可以使用的子集（以获得比如说可靠性，安全性，性能，或者别的什么）。
它们强烈地推崇使用一些简单的"扩展"（[程序库组件](#S-gsl)），
使得最易出错的 C++ 特性变得不再必须，并且可以（通过这些规则）禁止再使用它们。

这些规则都**强调静态类型安全性和资源安全性**。
鉴于此，它们**强调了进行范围检查**，避免对 `nullptr` 解引用，避免悬挂指针，以及（通过 RAII）系统性地使用异常的可能性。
部分地为达成这点，也部分地为了最小化会带来错误的晦涩难懂的代码，这些规则同样**强调了简单性**，以及将必须的复杂性隐藏于经过充分说明的接口后面。

有许多规则都是约定性质的。
我们认为，那些单纯说"禁止这样！"而又不提供替代方案的规则是不可取的。
但这样的后果就是让一些规则只能以启发式方法，而不是精确地和机械化地进行验证检查。
还有一些规则所表达的是一些一般性的原则。对于这些一般性规则，我们会提供一些更精细和更特定的规则来进行不完全的检查。

这些指导方针所关注的是 C++ 的核心部分及其使用方式。
我们认为大多数的大型团体，特定的应用领域，甚至**一些大型项目都会需要更多的规则**，也许是更多的限制规则，或是更多的库支持。
例如说，硬实时开发人员通常都无法随意使用自由存储（动态内存），并且在选择程序库上也有许多限制。
我们鼓励各方开发这样的专门规则，以作为我们的核心指导方针的补充。
请构建你自己的基础程序库并使用它，而不要把你的开发层次降低到汇编代码之中。

这些规则的设计使其能够进行[渐进式的采纳](#S-modernizing)。

**一些规则的目标是提升各种形式的安全性**，而另外一些的目标是**减少意外的发生**，还有许多则同时兼顾。
目标是避免意外事故的指导方针通常会禁止完全合法的 C++ 用法。
不管怎样，每当存在两种达成效果的方式，其中一种被证实是常见的错误来源，而另外一种并非如此时，我们都会努力引导程序员采纳后者。

## <a name="SS-non"></a>In.not: 非目标

我们没打算让这些规则保持精简或正交。
特别地说，一般性规则可以很简单，但却没办法强制实施。
而且要搞清楚一条一般性规则所造成的影响通常是很困难的。
通常更专门的规则都更易于理解清楚，也更易于实施，但如果没有那些一般性规则的话，它们不过是一大堆特殊情况而已。
我们既要提供能够帮到新手的规则，也要提供能够支持专家使用的规则。
其中的一些规则是完全可以强制实行的，而另外的一些则是基于启发式方案的规则。

并不需要像读书一样从头到尾地阅读这些规则。
您可以利用链接来进行浏览。
**不过，这些规则的主要预期用途是作为工具的检查目标。**
就是说，由工具来查找规则的违反情况，然后工具会返回指向所违反的规则的链接。
而规则之中则提供了其理由，违反规则的潜在后果的例子，以及一些改正建议。

这些指导方针并不是用来替代 C++ 的教程材料的。
如果您需要针对某个经验水平的教程，请参见[参考资料](#S-references)。

本文档并**不是一份如何把老旧 C++ 代码转化为更加现代的代码的指南。**
而是旨在以一种具体化的方式来阐明对于新代码的设想。
当然，对于进行代码现代化转换，使其恢复活力或者升级的可行方式，可以参考[代码现代化章节](#S-modernizing)。
重要的是，这些规则是允许渐进式采纳的：对大型代码库进行一次性全部转化通常都是不可行的。

这些指导方针并不会对于语言技术的每个细节上都保持完整和精确。
如果需要，请参考 C++ 标准，关于语言定义上的最终文本，其中包括一般性规则的每种例外情况，也包括所有特性。

这些规则不是为了强迫你使用 C++ 的某个阉割子集来编写代码的。
它们*尤其着重*避免去定义一种像（比如）Java 一样的 C++ 子集。
它们也避免去定义一个单一的所谓"真正的 C++"的语言。
我们重视语言的表达能力和不打折扣的性能。

这些规则并不是价值观中立的。
它们旨在**使代码变得相对于现有大多数 C++ 代码来说更简单，并且更加正确和安全，又不会有任何性能损失**。
它们旨在**约束对那些完全合法的，但却与错误、虚假的复杂性以及不良性能有关的 C++ 代码的使用**。

这些规则并未精炼到人们（或机器）可以无脑实施的程度。
"强制实施"部分试图做到这点，但相对于给出一些精确但却错误的东西来说，
我们更倾向于使得一条规则或者定义略微含糊，并允许不同的解读。
有时候，只有经历时间和经验的凝炼才能带来精确性。
设计（还）并不是数学的某种形式。

这些规则并不完美。
某条规则可能有害，因其可能制止了在特定情形中有益的事物。
某条规则可能有害，因其可能无法制止在特定情形中会导致某种严重错误的事物。
某条规则可能有许多害处，因其含混，有歧义，无法实施，或者对一个问题给出了所有的解决方案。
完全满足"无害"的准则是不可能的。
相对来讲，我们的目标并没那么大野心："**对大多数数程序员有最多的好处**"；
如果某条规则使你无法工作，你反对它，忽略掉它，但请不要削弱它，除非它已经变得没有意义。
同样，也请给出改进的建议。

## <a name="SS-force"></a>In.force: 强制实施

无法强制实施的规则对于大型代码库来说是难以操作的。
所有规则都强制实施，则仅对于一个小的规则集合，或者对于某些特定用户群来说是可行的。

* 但我们需要大量的规则，需要每个人都能使用的规则。
* 不同的人的要求都不一样。
* 人们不想阅读大量的规则。
* 人们也无法记住太多规则。

因此，我们需要建立规则子集以满足各种不同的需要。

* 但任意性地建立子集也会导致混乱。

我们想要的是可以帮助到许多人的指导方针，使**代码更加统一，并有力地促进人们将他们的代码现代化**。
我们想要促进最佳实践，而不是让人们陷入大量选项之中而增加管理压力。
理想情况是使用全部规则；这会带来极大的好处。

但这样也带来了一些困难之处。
我们试图通过使用工具来解决它们。
每条规则都包括一个**强制实施**小节，列出了进行强制实施的一些建议。
**所谓强制实施，可以是通过代码评审，通过静态分析，通过编译器，或者通过运行时检查来进行的**。
只要可行，我们都倾向于"机械性的"检查（人类是缓慢的，不精确的，而且很容易疲倦）和静态检查。
只有当不存在其他方案时，我们才偶尔建议进行运行时检查；我们并不想带来所谓"分散肥肉"。
如果适当的话，我们会（在**强制实施**小节中）将规则标以相关的规则组的名字（所谓"剖面配置"）。
一条规则可以属于多个剖面配置，也可以不属于任何剖面配置。
首先，我们有一些对应于常规需求（期望、理想目标）的剖面配置：

* **type**: 消除类型违规（如通过强制转换（cast），联合体（union），或者变参（varargs）把 `T` 重解释为 `U`）
* **bounds**: 消除边界违规（如越过数组范围的访问）
* **lifetime**: 消除泄漏（如未能 `delete` 或者进行多次 `delete`），以及消除对无效对象的访问（如解引用 `nullptr`，或使用悬挂引用）。

这些**剖面配置是为工具的使用而准备的**，但对人类读者也能有所帮助。
我们不打算把**强制实施**小节中的评述限定在我们了解如何强制实施的方面；其中的一些说明仅仅是一些愿望，它们可能会对一些工具构建者们造成影响。

实现这些规则的工具应当遵循下面的语法以明确抑制一条规则：

    [[gsl::suppress(tag)]]

其中的 "tag" 是包含强制规则的条目的锚定名字（例如，[C.134](#Rh-public) 的锚定名字为 "Rh-public"），
剖面配置的规则组的名字（如 "type"，"bounds"，或 "lifetime"），
或者剖面配置中的特定规则（[type.4](#Pro-type-cstylecast) 或 [bounds.2](#Pro-bounds-arrayindex)）。

## <a name="SS-struct"></a>In.struct: 本文档的结构

每条规则（指导方针，建议）可以包含几个部分：

* 规则本身 —— 例如，**不要使用裸 `new`**
* 一个规则参考编号 —— 例如，**C.7**（与类相关的第七条规则）。
  因为大章节之间天然是无序的，所以我们用字母来当作规则参考"编号"的第一个部分。
  我们在编号之间保留了一些间隔，以便当添加或删减规则时尽量减少"断裂"。
* **理由**（原理） —— **程序员对于他们不理解的规则是难于遵守的**
* **示例** —— 抽象地理解规则是很难的；**示例有正面的和负面的**
* **替代方案** —— 针对"请勿……"规则
* **例外** —— 我们更喜欢简单的一般性规则。但是许多规则都是广泛适用，但并不是普遍适用的，因此必须列出例外情况
* **强制实施** —— 关于这条规则如何"机械性"地进行检查的建议
* **参见** —— 指向相关的规则，以及（本文档中或者别处的）进一步讨论
* **注解** —— 需要说明的一些内容，无法被归类到其他部分
* **探讨** —— 指向规则主列表之外的更加全面的原理说明和实例

一些规则难于机械地进行检查，但它们都满足一条最小准则，即专家程序员可以不费太多力气就能找出许多违反情况。
我们希望"机械性"工具能够随着时间获得改进，以接近这种专家程序员所能发觉的程度。
而且，我们还认为这些规则也会随着时间获得提炼，以变得更明确和易于检查。

规则应当简明，而不是谨慎地列出每种变化和特殊情况。
这些信息应当出现在**替代方案**段落和[探讨](#S-discussion)章节中。
如果您不理解或者反对一条规则，请您访问它的**探讨**部分。
如果您觉得一份探讨有缺漏或不完整，请填写一条 [Issue](https://github.com/isocpp/CppCoreGuidelines/issues)
来解释您的关切，亦或一条相应的问题报告。

各个示例用于演示规则。
* 这些示例并非意图具有产品级的质量，或覆盖所有的教学维度。
例如，许多的例子都是语言技巧，并使用了诸如 `f`，`base`，和 `x` 这样的名字。
* 我们尝试保证使下文中"好"的示例都遵守《核心指导方针》。
* 注释通常用于演示规则，它们可能是不必要的，或者会干扰"真正的代码"。
* 我们假设读者**具有标准程序库的知识**。例如我们使用普通的 `vector` 而不是 `std::vector`。

本文档不是语言手册。
它旨在能够对人有所帮助，而不是变得完整，在技术细节上完全准确，或对现存代码的指南。
可以在[参考资料](#S-references)中找到一些推荐的信息来源。

## <a name="SS-sec"></a>In.sec: 主章节

* [In: 导言](#S-introduction)
* [P: 理念](#S-philosophy)
* [I: 接口](#S-interfaces)
* [F: 函数](#S-functions)
* [C: 类和类层次](#S-class)
* [Enum: 枚举](#S-enum)
* [R: 资源管理](#S-resource)
* [ES: 表达式和语句](#S-expr)
* [Per: 性能](#S-performance)
* [CP: 并发与并行](#S-concurrency)
* [E: 错误处理](#S-errors)
* [Con: 常量和不可变性](#S-const)
* [T: 模板和泛型编程](#S-templates)
* [CPL: C 风格的编程](#S-cpl)
* [SF: 源文件](#S-source)
* [SL: 标准库](#S-stdlib)

配套章节：

* [A: 架构相关的理念](#S-A)
* [NR: 伪规则和错误的看法](#S-not)
* [RF: 参考资料](#S-references)
* [Pro: 剖面配置](#S-profile)
* [GSL: 指导方针支持库](#S-gsl)
* [NL: 命名和代码布局](#S-naming)
* [FAQ: 常见问题的解答](#S-faq)
* [附录 A: 程序库](#S-libraries)
* [附录 B: 代码的现代化转换](#S-modernizing)
* [附录 C: 相关讨论](#S-discussion)
* [附录 D: 支持工具](#S-tools)
* [词汇表](#S-glossary)
* [To-do: 未分类的规则原型](#S-unclassified)

章节之间并非是正交的。

每个章节（比如，"P" 代表"理念"），以及每个子章节（比如，"C.hier" 代表"类层次（OOP）"）都有一个用以简化搜索和引用的缩写。
主章节的缩写也出现在规则编号之中（比如，"C.11" 代表"使具体类型正规化"）。

# <a name="S-philosophy"></a>P: 理念

本章节中的规则都非常具有一般性。

理念性规则概览：

* [P.1: 在代码中直接表达你的想法](#Rp-direct)
* [P.2: 用 ISO 标准 C++ 来编码](#Rp-Cplusplus)
* [P.3: 表达你的设计意图](#Rp-what)
* [P.4: 理想情况下，程序应当是静态类型安全的](#Rp-typesafe)
* [P.5: 编译期检查优先于运行时检查](#Rp-compile-time)
* [P.6: 应当使无法在编译期进行的检查能够在运行时实施](#Rp-run-time)
* [P.7: 尽早识别运行时错误](#Rp-early)
* [P.8: 不要泄漏任何资源](#Rp-leak)
* [P.9: 不要浪费时间或空间](#Rp-waste)
* [P.10: 不可变数据优先于可变数据](#Rp-mutable)
* [P.11: 把杂乱的构造封装起来，而别让其散布到代码中](#Rp-library)
* [P.12: 适当采用支持工具](#Rp-tools)
* [P.13: 适当采用支持程序库](#Rp-lib)

通常，理念性的规则都无法机械性地进行检查。
不过，这些理念主题在各个规则中都有体现。
如果没有一个理念基础的话，那些更具体、专门和可检查的规则就是缺少理论根据的了。

### <a name="Rp-direct"></a>P.1: 在代码中直接表达你的想法

##### 理由

编译器是不会去读注释（或设计文档）的，许多程序员也（固执地）不去读它们。
而代码中所表达的东西是带有明确的语义的，并且（原则上）是可以由编译器和其他工具进行检验的。

##### 示例

```c++
class Date {
public:
    Month month() const;  // 好
    int month();          // 不好
    // ...
};
```

`month` 的第一个声明式，显然是要返回一个 `Month`，而且**不会修改 `Date` 对象的状态**。
而第二个版本则需要读者进行猜测，同时带来了更多的出现难于发现 BUG 的可能性。

##### 示例，不好

这个循环是 `std::find` 的一种能力有限的形式：

```c++
void f(vector<string>& v)
{
    string val;
    cin >> val;
    // ...
    int index = -1;                    // 不好，而且应该使用 gsl::index
    for (int i = 0; i < v.size(); ++i) {
        if (v[i] == val) {
            index = i;
            break;
        }
    }
    // ...
}
```

##### 示例，好

要清晰得多地表达其设计意图，可以这样：

```c++
void f(vector<string>& v)
{
    string val;
    cin >> val;
    // ...
    auto p = find(begin(v), end(v), val);  // 好多了
    // ...
}
```

**用恰当设计的程序库来表达设计意图**（要做什么，而不只是怎么做这些事），要远比直接使用语言功能好得多。

**C++ 程序员应当熟知标准库的基本知识，并在适当的时候加以利用**。
任何程序员都应当熟知其所工作的项目中的**基础程序库的基本知识**，并适当加以利用。
使用本文档的指导方针的程序员，应当熟知[指导方针支持库](#S-gsl)，并适当加以利用。

##### 示例

```c++
change_speed(double s);   // bad: s 代表什么？
// ...
change_speed(2.3);
```

更好的方案是明确给出这个 double 的含义（新的速度还是对旧速度的增量？）以及所用单位：

```c++
change_speed(Speed s);    // 好多了：说明了 s 的含义
// ...
change_speed(2.3);        // 错误：没有单位
change_speed(23m / 10s);  // 米每秒
```

确实可以用普通的（没有单位的）`double` 作为增量值，但这样是易于出错的。
如果绝对速度值和增量值都需要的话，我们应当定义一个 `Delta` 类型。

##### 强制实施

通常非常困难。

* 坚持一贯地使用 `const`（检查成员函数**是否会修改对象**；检查函数是否**会修改以指针或引用**形式传递的实参）
* 将**强制转换标示出来**（强制转换阉割了类型系统）
* 检测模仿标准库的代码（困难）

### <a name="Rp-Cplusplus"></a>P.2: 用 ISO 标准 C++ 来编码

##### 理由

本文档正是关于用 ISO 标准 C++ 来编码的一组指导方针。

##### 注解

有些环境下是需要使用语言扩展的，例如有关访问系统资源的语言扩展。
这些情况下，应当将对所需**语言扩展的使用局部化**，并把它们的使用置于非核心的编码指导方针的控制之下。如果可能的话，**应当构建一些接口来封装**这些语言扩展，**以使其能够被关闭**，并当针对不支持这些语言扩展的系统时免除它们的编译。

语言扩展通常是没有严密定义的语义的。即便语言扩展很常见，并且在多种编译器上都有实现，它们也可能有略微不一致的行为以及边界情形下的行为，这是*缺乏*一个严格的标准定义的直接后果。大量使用任何这样的语言扩展，都**会对代码的可移植性造成不良影响**。

##### 注解

使用合法的 C++ 并不能保证可移植性（不管其正确性）。应当**避免依赖于未定义的行为**（例如，[未定义的求值顺序](#Res-order)）并应当关注带有由实现定义的含义的构造（例如，`sizeof(int)`）。

##### 注解

有些环境下是需要对标准 C++ 语言或者程序库的**功能特性的使用进行限制**的，例如，飞行器控制软件标准要求避免动态内存分配。

这些情况下，应当将对它们的使用（或废弃）置于对本文档针对特定环境所定制的扩充的编码指导方针之下。

##### 强制实施

使用最新版的 C++ 编译器（当前支持 C++17，C++14 或 C++11），并打开**禁用语言扩展**的选项。

### <a name="Rp-what"></a>P.3: 表达你的设计意图

##### 理由

一些代码如果不（比如通过命名或者代码注释）**说明其设计意图**的话，是不可能搞清楚代码是否达成其预定目标的。

##### 示例

```c++
gsl::index i = 0;
while (i < v.size()) {
    // ... 在 v[i] 上做一些事 ...
}
```

这里并未表明其意图是"单纯地"循环访问 `v` 的元素。使用一个索引的实现细节被暴露了出来（因而可能导致被误用），**而且 `i` 的存在超出了循环的范围**，这也许符合也许违背了设计意图。读者仅从这段代码中是无法了解清楚的。

更好的方式是：

```c++
for (const auto& x : v) { /* 用 x 的值做一些事 */ }
```

现在，循环机制不明确给出，而且循环的操作针对的是 `const` 元素，以**防止发生意外的修改**。如果需要进行修改的话，则可以这样：

```c++
for (auto& x : v) { /* 修改 x */ }
```

`for` 语句的更多细节，请参见 [ES.71](#Res-for-range)。
有时候，**使用具名的算法**会更好。 这个示例使用 Ranges TS 中的 `for_each`，因为它直接表达了意图：

```c++
for_each(v, [](int x) { /* 用 x 的值做一些事 */ });
for_each(par, v, [](int x) { /* 用 x 的值做一些事 */ });
```

最后一种写法让人明白，我们并**不关心何种顺序**来处理 `v` 的各个元素。

程序员应当熟悉：

* [指导方针支持库](#S-gsl)
* [ISO C++ 标准库](#S-stdlib)
* 当前项目所使用的任何**基础程序库**

##### 注解

其他形式：说明要做什么，而不只是怎么做这些事。

##### 注解

一些语言构造比另一些可以更好地表达设计意图。

##### 示例

如果要用两个 `int` 来代表二维点的坐标值，应当这样：

```c++
draw_line(int, int, int, int);  // 含混的
draw_line(Point, Point);        // 清晰的
```

##### 强制实施

查找具有更加**替代方案**的一般模式：

* 简单 `for` **循环** vs. 范围式 `for` 循环
* `f(T*, int)` 接口 vs. `f(span<T>)` **接口**
* **循环变量出现在过大的范围**中
* 裸的 `new` 和 `delete`
* 带有**大量内建类型的形参**的函数

在聪敏的人工处理和半自动的程序变换之间存在巨大的空间。

### <a name="Rp-typesafe"></a>P.4: 理想情况下，程序应当是静态类型安全的

##### 理由

理想情况下，程序应当完全是**静态（编译期）类型安全的**。
不幸的是，这是不可能的。有问题的领域：

* `union`
* **强制转换**
* **数组衰退**
* **范围**错误
* **窄化转换**

##### 注解

**这些领域是许多严重问题（如程序崩溃和安全性违规）的来源**。
我们争取为它们给出替代技术。

##### 强制实施

如果程序各自需要或者条件允许的话，我们可以逐个对这些问题类型分别进行阻止、克制或者检测。
我们总会给出替代方案。
例如：

* `union` - 使用 `variant`（C++17 提供）
* **强制转换 - 尽可能减少**其使用；**使用模板**有助于这点
* **数组衰退** - 使用 `span`（来自 GSL）
* **范围错误** - 使用 `span`
* **窄化转换 - 尽可能减少其使用**，必须使用时则使用 `narrow` 或者 `narrow_cast`（来自 GSL）

### <a name="Rp-compile-time"></a>P.5: 编译期检查优先于运行时检查

##### 理由

为了代码清晰性和性能。
**对于编译期识别的错误是不需要编写错误处理的**。

##### 示例

```c++
// Int 被用作整数的别名
int bits = 0;         // 请勿如此: 可以避免的代码
for (Int i = 1; i; i <<= 1)
    ++bits;
if (bits < 32)
    cerr << "Int too small\n";
```

这个例子并没有达成其所要达成的目的（**因为溢出是未定义行为**），应当被替换为简单的 `static_assert`：

```c++
// Int 被用作整数的别名
static_assert(sizeof(Int) >= 4);    // do: 编译时检查
```

或者更好的方式是直接利用类型系统，将 `int` 替换 `int32_t`。

##### 示例

```c++
void read(int* p, int n);   // 读取至多 n 个整数到 *p 之中

int a[100];
read(a, 1000);    // 不好，超过末尾了
```

更好的做法是

```c++
void read(span<int> r); // 读取到整数区域范围 r 之中

int a[100];
read(a);        // 好多了: 让编译器确定元素数量
```

**替代形式**: 不要把可以在编译期搞定的事推后到运行时进行。

##### 强制实施

* **查找指针参数**。
* 查找运行时进行的**范围违反检查**。

### <a name="Rp-run-time"></a>P.6: 应当使无法在编译期进行的检查能够在运行时实施

##### 理由

把难于检测的错误遗留在程序中，总会带来程序崩溃或得到错误的运行结果。

##### 注解

理想情况下我们可以在编译期或者运行时识别所有的错误（它们并非程序员的逻辑错误）。但是要在编译期识别所有的错误是不可能的，而通常也负担不起在运行时识别剩余的全部错误的代价。不过我们编写程序，应当尽量使其在原则上是可以在充足的（分析程序，运行时检查，机器资源，时间等）资源下进行检查的。

##### 示例，不好

```c++
// 分离编译，可能会被动态加载
extern void f(int* p);

void g(int n)
{
    // 不好的：并未把元素数量传递给 f()
    f(new int[n]);
}
```

此处，**关键性的信息（元素数量）被完全掩盖**起来，使其无法进行静态分析，而如果 `f()` 属于某个 ABI 的一部分的话，由于无法对这个指针进行"测量插装"，运行时检查也是不可行的。我们确实可以在自由存储中插入有助于检查的信息，但这需要对系统甚至是编译器做出整体改动。这就是一个能让错误检查变得非常困难的设计。

##### 示例，不好

当然可以把元素数量和指针一起进行传递：

```c++
// 分离编译，可能会被动态加载
extern void f2(int* p, int n);

void g2(int n)
{
    f2(new int[n], m);  // 不好的：可能会把错误的元素数量传递给 f()
}
```

把元素数量作为一个参数进行传递，比只传递指针而依靠某种（不明确的）对已知元素个数的约定或者找出元素个数的方式，要好得多，而且是更加常见的做法。但是如上所示，**一个简单的错字就可以引入一个严重的错误**。`f2()` 的两个参数之间的关联是基于约定的，而并不明确。

而且，这里还隐含假定 `f2()` **应当 `delete` 其参数**（要不然就是调用者又犯了另一个错误）。

##### 示例，不好

使用标准库的**资源管理指针**指向对象时，也**不能传递其大小**：

```c++
// 分离编译，可能会被动态加载
// NB: 这里假定调用代码是 ABI 兼容的，使用的是
// 兼容的 C++ 编译器和同一个 stdlib 实现
extern void f3(unique_ptr<int[]>, int n);

void g3(int n)
{
    f3(make_unique<int[]>(n), m);    // 不好的：把所有权和大小分开进行传递
}
```

##### 示例

我们得把**指针和元素数量作为一个对象整体**来进行传递：

```c++
extern void f4(vector<int>&);   // 分离编译，可能会被动态加载
extern void f4(span<int>);      // 分离编译，可能会被动态加载
                                // NB: 这里假定调用代码是 ABI 兼容的，使用的是
                                // 兼容的 C++ 编译器和同一个 stdlib 实现

void g3(int n)
{
    vector<int> v(n);
    f4(v);                     // 传递引用，保留所有权
    f4(span<int>{v});          // 传递视图，保留所有权
}
```

这个设计将**元素数量作为对象的固有部分**，因此不太可能有错误，动态（运行时的）检查即使不总是可承担的，也总是可行的。

##### 示例

如果把所有权和验证所需的全部信息一起传递的话会怎么样呢？

```c++
vector<int> f5(int n)    // OK: 移动
{
    vector<int> v(n);
    // ... 初始化 v ...
    return v;
}

unique_ptr<int[]> f6(int n)    // 不好的：缺失了 n
{
    auto p = make_unique<int[]>(n);
    // ... 初始化 *p ...
    return p;
}

owner<int*> f7(int n)    // 不好的：缺失了 n 并且我们可能会忘记 delete
{
    owner<int*> p = new int[n];
    // ... 初始化 *p ...
    return p;
}
```

##### 示例

* ???
* 展示传递多态基类的接口是如何避开可能进行的检查的，但它们实际上直到它们需要的类型？
  还有用字符串当作"自由式"选项的做法

##### 强制实施

* 标示出 (pointer, count) 形式的接口（这将标示出大量的因为兼容性原因而无法进行修正的实例）
* ???

### <a name="Rp-early"></a>P.7: 尽早识别运行时错误

##### 理由

避免"神秘的"程序崩溃。
避免能够产生（也许无法识别的）错误结果的程序错误。

##### 示例

```c++
void increment1(int* p, int n)    // 不好的：易于出错
{
    for (int i = 0; i < n; ++i) ++p[i];
}

void use1(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment1(a, m);   // 可能是打错字，可能假定有 m <= n
                        // 不过让我们假设 m == 20
    // ...
}
```

我们在 `use1` 里面犯了一个能够导致**数据损坏或程序崩溃**的小错误。
这个 (pointer, count) 形式的接口让 `increment1()` **没有可以使其防范越界错误**的任何现实可行的方式。
如果我们可以检测到越界访问的下标的话，那么这个错误直到对 `p[10]` 进行访问之前都不会被发现。
我们可以提早进行检查来改进这个代码：

```c++
void increment2(span<int> p)
{
    for (int& x : p) ++x;
}

void use2(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment2({a, m});    // 可能是打错字，可能假定有 m<=n
    // ...
}
```

现在，就可以在调用点（提早地）检查 `m <= n`，而不是更晚进行了。
如果我们只是打错了字而本想用 `n` 作为边界值的话，代码还可以进一步简化（来消除一处错误的可能性）：

```c++
void use3(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment2(a);   // 不需要重复给出 a 的元素数量
    // ...
}
```

##### 示例，不好

**不要对同一个值重复进行检查。不要用字符串来传递有结构的数据**：

```c++
Date read_date(istream& is);    // 从 istream 读取日期

Date extract_date(const string& s);    // 从 string 中抽取日期

void user1(const string& date)    // 操作 date
{
    auto d = extract_date(date);
    // ...
}

void user2()
{
    Date d = read_date(cin);
    // ...
    user1(d.to_string());
    // ...
}
```

这个日期被（`Date` 的构造函数）验证了两次，并以字符串（无结构的数据）的形式来传递。

##### 示例

**过量的检查可能是代价昂贵的**。
有些情况下提早检查可能是愚蠢的，因为你可能根本不需要这个值，或者可能仅需要值的一部分，而这要比进行整体的检查容易得多。同样来说，不要添加能够改变接口的渐进式行为的验证性检查（例如，不要在平均复杂度为 `O(1)` 的接口中添加一个 `O(n)` 的检查）。

```c++
class Jet {    // 物理规则是: e * e < x * x + y * y + z * z
    float x;
    float y;
    float z;
    float e;
public:
    Jet(float x, float y, float z, float e)
        :x(x), y(y), z(z), e(e)
    {
        // 应不应该在这里检查这些值是物理上有意义的？
    }

    float m() const
    {
        // 应不应该处理这里的退化情形？
        return sqrt(x * x + y * y + z * z - e * e);
    }

    ???
};
```

喷流（Jet）的物理定律（`e * e < x * x + y * y + z * z`），由于可能存在测量误差的缘故并不是不变式。

???

##### 强制实施

* 查找**指针和数组**：**提早且不要重复进行范围检查**
* 查找**类型转换**：**消除或标示出窄化转换**
* 查找**未经检查的来自输入的值**。
* 查找**被转换成字符串的结构化数据**（带有不变式的类的对象）
* ???

### <a name="Rp-leak"></a>P.8: 不要泄漏任何资源

##### 理由

**即使是缓慢的资源增长，随着时间推移**，也会耗尽这些资源的可用性。
这对于长时间运行的程序来说尤其重要，而且是负责任的编程行为的基础方面。

##### 示例，不好

```c++
void f(char* name)
{
    FILE* input = fopen(name, "r");//属于裸new系列
    // ...
    if (something) return;   // 不好的：如果 something == true 的话，将会泄漏一个文件句柄
    // ...
    fclose(input);
}
```

建议采用 [RAII](#Rr-raii)：

```c++
void f(char* name)
{
    ifstream input {name};
    // ...
    if (something) return;   // OK: 没有泄漏
    // ...
}
```

**参见**: [资源管理相关章节](#S-resource)

##### 注解

通俗地说，**泄漏就是"有东西没清理干净"**。
一种更重要的分类方式是"有东西无法再被清理干净"。
例如，在堆上分配一个对象，然后又丢失了最后一个指向这份分配物的指针。
不应当将这条规则误读为，要求在程序终止时必须把长期存活的对象中的分配物进行回收。
例如，依赖于系统所保证的**进程停止时进行的文件关闭和内存回收行为可以简化代码**。
然而，**依赖于进行隐式清理的抽象机制同样简单**，而且通常更加安全。

##### 注解

强制实行[生存期安全性剖面配置](#SS-lifetime)可以消除泄漏的发生。
如果和 **[RAII](#Rr-raii) 所提供的资源安全性组合到一起**，也可以（通过不产生任何垃圾而）消除对"垃圾收集"的需要。
如果将之和[类型和边界剖面配置](#SS-force) 组合到一起强制实施的话，你将会得到完全的类型和资源安全性，这是通过使用工具来保证的。

##### 强制实施

* 查找指针：把它们分成非所有者（默认情形）和所有者。
  如果可行的话，把**所有者替换为标准库的资源封装类**（如上例所示）。
  或者，也可以把这种所有者用 [GSL](#S-gsl) 中的 `owner` 进行标记。
* **查找裸露的 `new` 和 `delete`**
* 查找已知的**返回原始指针的资源分配函数**（诸如 `fopen`，`malloc`，和 `strdup` 等）

### <a name="Rp-waste"></a>P.9: 不要浪费时间或空间

##### 理由

你用的语言是 C++。

##### 注解

为达成某个目标（例如**开发速度，资源安全性，或者测试的简化**等）而正当花费的时间和空间是不会被浪费的。
"力求高效的另一种好处是，这一过程将强迫你更深入地理解问题。"—— Alex Stepanov

##### 示例，不好

```c++
struct X {
    char ch;
    int i;
    string s;
    char ch2;

    X& operator=(const X& a);
    X(const X&);
};

X waste(const char* p)
{
    if (!p) throw Nullptr_error{};
    int n = strlen(p);
    auto buf = new char[n];
    if (!buf) throw Allocation_error{};
    for (int i = 0; i < n; ++i) buf[i] = p[i];
    // ... 对缓冲区进行操作 ...
    X x;
    x.ch = 'a';
    x.s = string(n);    // 在 x.s 上预留 *p 的空间
    for (gsl::index i = 0; i < x.s.size(); ++i) x.s[i] = buf[i];  // 把 buf 复制给 x.s
    delete[] buf;
    return x;
}

void driver()
{
    X x = waste("Typical argument");
    // ...
}
```

这个确实有些夸张，但我们在产品代码中能够见到这里所犯的每个错误，甚至更糟糕。
注意，`X` 的布局保证会浪费至少 6 个字节，而且很可能更多。
**错误的复制操作的定义式废掉了移动语义**，使返回操作变得更慢
（请注意这里并**不会保证进行返回值优化**（RVO））。
为 `buf` 使用的 `new` 和 `delete` 是多余的；如果确实想要一个局部的字符串的话，我们**应当使用局部的 `string`**。
还有几个其他的性能 BUG 和无理由的复杂性。

##### 示例，不好

```c++
void lower(zstring s)
{
    for (int i = 0; i < strlen(s); ++i) s[i] = tolower(s[i]);
}
```

这个其实是一个来自产品代码的例子。
可以看到这里有一句 `i < strlen(s)`。这个表达式在循环的每次重复中都要求值，这意味着每次循环中 `strlen` **都必须走完字符串以确定其长度**。我们假定在改动字符串内容过程中`toLower` 不会影响字符串的长度，因此最好**在循环外面缓存长度值，而不是在每次重复中都承担其代价**。

##### 注解

单个造成浪费的范例很少是显著的，而一旦它是显著的，通常也可以被高手轻易地清除掉。
但是，代码库中放任地到处散布的浪费情况，则很容易变得显著，而高手们又不像我们期望那样总是有空的。
本条规则（以及其他配套的更加具体的规则）的目的是，将与 C++ 语言的使用有关的大多数浪费情况，在其发生之前就将之清除掉。
在这之后，我们就可以查找与算法和需求有关的浪费情况了，但这超出了我们的指导方针的范畴。

##### 强制实施

许多更加具体的规则都是针对**追求简单性并清除无理由浪费**的总体目标的。

* 当用户定义的非预置后缀 `operator++` 或 `operator--` 函数的返回值未被使用时进行标记。优先代之以采用前缀形式。（注：使用"用户定义的非预置"是为了减弱噪声。若实践中噪声还是很显著则需要重新审视这条强制措施。）


### <a name="Rp-mutable"></a>P.10: 不可变数据优先于可变数据

##### 理由

**对常量进行推理要比变量简单得多**。
**不可变的事物是不可能被意外改变的**。
**不可变性有时候也带来更好地进行优化的机会**。
**在常量上不会出现数据竞争**。

另见 [Con: 常量和不可变性](#S-const)

### <a name="Rp-library"></a>P.11: 把杂乱的构造封装起来，而别让其散布到代码中

##### 理由

**杂乱的代码更有可能隐藏有 Bug 而且难于编写**。
**而好的接口使用起来更容易和安全**。
杂乱的，底层的代码会混杂出更多这样的代码。

##### 示例

```c++
int sz = 100;
int* p = (int*) malloc(sizeof(int) * sz);
int count = 0;
// ...
for (;;) {
    // ... 读取一个 int 到 x 中，如果达到文件尾就退出循环 ...
    // ... 检查 x 有效 ...
    if (count == sz)
        p = (int*) realloc(p, sizeof(int) * sz * 2);
    p[count++] = x;
    // ...
}
```

**这段代码是低层的，啰嗦的，而且易错的**。
比如说，**我们就"忘了"检查内存耗尽情况**。
我们可以代之以使用 `vector`：

```c++
vector<int> v;
v.reserve(100);
// ...
for (int x; cin >> x; ) {
    // ... 检查 x is 有效 ...
    v.push_back(x);
}
```

##### 注解

标准库和 GSL 都是这种理念的例子。
例如，我们并不使用混乱的数组，联合体，强制转换，麻烦的生存期问题，`gsl::owner`，等等，
它们用于实现一些关键抽象，诸如 `vector`，`span`，`lock_guard`，以及 `future`，**我们使用的是**
**一般来说比我们有更多时间和专业能力的人所设计和实现的程序库**。
类似地，我们也能够而且应该设计并实现更专门的程序库，而不是将其留给用户（通常是我们自己）
来面对需要重复把低级代码搞正确的挑战。
这是作为指导方针基石的[超集的子集原则](#R0)的一种变体。

##### 强制实施

* 查找如**复杂指针操作和在抽象的实现外面进行强制转换这样的"混乱代码"**。


### <a name="Rp-tools"></a>P.12: 适当采用支持工具

##### 理由

许多事情机器都比人做得更好。
**对于重复劳动，计算机既不会累也不会厌烦**。
相对于重复性的例行任务，我们通常可以做一些更有意义的事情。

##### 示例

运行**静态分析工具来验证你的代码**是否遵循了你想要遵循的指导方针。

##### 注解

参见

* [静态分析工具](???)
* [并发工具](#Rconc-tools)
* [测试工具](???)

还有许多其他种类的工具，诸如源代码仓库和构建工具等等，
但这些超出了本指导方针的范围。

##### 注解

当心**不要**变得对过于详细定制的或者**过于专门的工具链产生依赖**。
它们会使得你本来可移植的代码**变得不可移植**。


### <a name="Rp-lib"></a>P.13: 适当采用支持程序库

##### 理由

使用设计良好，文档全面，并且有良好支持的程序库可以节省时间和工作量；
如果你的大部分工时都必须耗费在实现上的话，
程序库的质量和文档很可能要比你能做到的要好得多。
**程序库的成本（时间，工作量和资金等等）可以由大量的用户**所分担。
一个被广泛应用的程序库，远比一个独立的应用程序更加能够保持为最新状态，并被移植到新的系统之上。
**对于被广泛应用的程序库的相关知识，也可以节省其他或未来的项目中的时间**。
因此，如果你的应用领域中存在合适的程序库的话，请使用它。

##### 示例

```c++
std::sort(begin(v), end(v), std::greater<>());
```

如果你不是排序算法方面的专家而且有大量时间的话，
这样的代码比你为特定的应用所编写的任何代码都更可能正确并且运行得更快。
**不使用标准库（或者你的应用所采用的基础程序库）是需要明确理由**的，而不是反过来。

##### 注解

默认应当优先使用

* [ISO C++ 标准库](#S-stdlib)
* [指导方针支持库](#S-gsl)

##### 注解

如果某个重要的领域中不存在设计良好，文档全面，并且有良好支持的程序库的话，
可能应当由你来设计并实现它，再进行使用了。


# <a name="S-interfaces"></a>I: 接口

**接口是程序中的两个部分之间的契约**。严格地规定服务提供者和该服务使用者的预期是必要的。
在代码的组织中，良好的接口（**易于理解，促进高效的使用方式，不易出错，支持进行测试**，等等）可能是最重要的单个方面了。

接口规则概览：

* [I.1: 使接口明确](#Ri-explicit)
* [I.2: 避免非 `const` 全局变量](#Ri-global)
* [I.3: 避免使用单例](#Ri-singleton)
* [I.4: 使接口严格和强类型化](#Ri-typed)
* [I.5: 说明前条件（如果有）](#Ri-pre)
* [I.6: 优先使用 `Expects()` 来表达前条件](#Ri-expects)
* [I.7: 说明后条件](#Ri-post)
* [I.8: 优先使用 `Ensures()` 来表达后条件](#Ri-ensures)
* [I.9: 当接口是模板时，用概念来文档化其参数](#Ri-concepts)
* [I.10: 使用异常来表明无法实施所要求的任务](#Ri-except)
* [I.11: 决不以原始指针（`T*`）或引用（`T&`）来传递所有权](#Ri-raw)
* [I.12: 把不能为空的指针声明为 `not_null`](#Ri-nullptr)
* [I.13: 不要只用一个指针来传递数组](#Ri-array)
* [I.22: 避免全局对象之间进行复杂的初始化](#Ri-global-init)
* [I.23: 保持较少的函数参数数量](#Ri-nargs)
* [I.24: 避免出现相邻而无关的相同类型的参数](#Ri-unrelated)
* [I.25: 优先以抽象类作为类层次的接口](#Ri-abstract)
* [I.26: 当想要跨编译器的 ABI 时，使用一个 C 风格的语言子集](#Ri-abi)
* [I.27: 对于稳定的程序库 ABI，考虑使用 Pimpl 手法](#Ri-pimpl)
* [I.30: 将有违规则的部分封装](#Ri-encapsulate)

**参见**

* [F: 函数](#S-functions)
* [C.concrete: 具体类型](#SS-concrete)
* [C.hier: 类层次](#SS-hier)
* [C.over: 函数重载和重载运算符](#SS-overload)
* [C.con: 容器和其他资源封装类](#SS-containers)
* [E: 错误处理](#S-errors)
* [T: 模板和泛型编程](#S-templates)

### <a name="Ri-explicit"></a>I.1: 使接口明确

##### 理由

正确性。**未在接口中规定的假设很容易被忽视而且难于测试**。

##### 示例，不好

**通过全局**（命名空间作用域）**变量**（调用模式）**来控制函数的行为，是隐含的**，而且潜在会造成困惑。例如：

```c++
int round(double d)
{
    return (round_up) ? ceil(d) : d;    // 请勿："不可见的"依赖
}
```

两次调用 `round(7.2)` 的含义**可能给出不同的结果**，这对于调用者来说是不明显的。

##### 例外

我们有时候会通过环境变量来控制一组操作的细节，比如常规/详细的输出，或者调试/优化版本。
使用非局部的控制方式可能带来困惑，但可以只用来控制实现的细节，否则就只有固定的语义了。

##### 示例，不好

通过非局部变量（比如 `errno`）进行的报告经常被忽略。例如：

```c++
// 请勿：printf 的返回值未进行检查
fprintf(connection, "logging: %d %d %d\n", x, y, s);
```

要是连接已经关闭而导致没有产生日志输出的话会怎么样？参见 I.???。

**替代方案**: 抛出异常。**异常是无法被忽略的**。

**其他形式**: **避免通过非局部**或者隐含的状态**来跨越接口传递信息**。
注意，非 `const` 的成员函数会通过对象的状态来向其他成员函数传递信息。

**其他形式**: **接口应当是函数或者一组函数集合**。
函数可以是模板函数，而函数集合可以是类或者类模板。

##### 强制实施

* 【简单】 函数**不能基于**声明于命名空间**作用域的变量**来作出**影响控制流**的决定。
* 【简单】 函数**不能**对声明于命名空间**作用域的变量**进行**写入操作**。

### <a name="Ri-global"></a>I.2: 避免非 `const` 全局变量

##### 理由

**非 `const` 全局变量能够隐藏依赖关系**，并使这些依赖项可能出现**无法预测**的变动。

##### 示例

```c++
struct Data {
    // ... 大量成员 ...
} data;            //  非 const 数据

void compute()     // 请勿这样做
{
    // ... 使用 data ...
}

void output()     // 请勿这样做
{
    // ... 使用 data ...
}
```

哪个可能会修改 `data` 呢？

##### 注解

**全局常量是有益的**。

##### 注解

针对全局变量的规则同样**适用于命名空间作用域的变量**。

**替代方案**: 如果你用全局（或者更一般地说命名空间作用域）数据来避免复制操作的话，请考虑把**数据以 `const` 引用的形式进行传递**的方案。
另一种方案是把**数据定义为某个对象的状态**，而把**操作定义为其成员函数**。

**警告**: 请关注数据竞争：当一个线程能够访问非局部数据（或以引用传递的数据），而另一个线程执行被调用的函数时，就**可能带来数据竞争**。
**指向可变数据的每个指针或引用**都是**潜在的数据竞争**。

##### 注解

**不可变数据**是不会带来数据竞争条件的。

**参见**: 另见[关于调用函数的规则](#SS-call)。

#### 注解

这条规则是"避免"，而不是"不要用"。当然是有（罕见）例外的，比如 `cin`、`cout` 和 `cerr`。

##### 强制实施

【简单】 **报告**所有在命名空间**作用域中声明的非 `const` 变量**。

### <a name="Ri-singleton"></a>I.3: 避免使用单例

##### 理由

**单例**基本上就是经过**伪装的更复杂的全局对象**。

##### 示例

```c++
class Singleton {
    // ... 大量代码，用于确保只创建一个 Singleton，
    // 进行正确地初始化，等等
};
```

单例的想法有许多变种。
这也是问题的一方面。

##### 注解

如果**不想让全局对象被改变**，请将其声明为 **`const` 或 `constexpr`**。

##### 例外

你可以使用**最简单的"单例"形式**（简单到通常不被当作单例）来获得首次使用时进行初始化的效果：

```c++
X& myX()
{
    static X my_x {3};
    return my_x;
}
```

这是解决初始化顺序相关问题的最有效方案之一。
在**多线程环境中，静态对象的初始化并不会引入数据竞争条件**
（**除非**你不小心**在其构造函数中访问了某个共享对象**）。

注意**局部的 `static` 对象初始化并不会蕴含竞争条件**。
不过，如果 `X` 的**销毁中涉及了需要进行同步的操作的话，我们就得用一个不那么简单的方案**。
例如：

```c++
X& myX()
{
    static auto p = new X {3};
    return *p;  // 有可能泄漏
}
```

这样就必须有人以某种适当的**线程安全方式来 `delete` 这个对象了**。
这是容易出错的，因此除了以下情况外我们并不使用这种技巧：

* `myX` 是在多线程代码中，
* 这个 `X` 对象需要销毁（比如由于它要释放某个资源），而且`X` 的析构函数的代码需要进行同步。

如果你和许多人一样把单例定义为只能创建一个对象的类的话，**像 `myX` 这样的函数并非单例**，而且这种好用的技巧并不算无单例规则的例外。

##### 强制实施

通常非常困难。

* 查找名字中包含 `singleton` 的类。
* 查找**只创建一个对象的类**（通过对**对象计数**或者**检查其构造函数**）。
* 如果某个类 X 具有**公开的静态函数**，并且它包含具有该类 X 类型的**函数级局部静态变量**并**返回**指向它的**指针**或者**引用**，**就禁止它**。

### <a name="Ri-typed"></a>I.4: 使接口严格和强类型化

##### 理由

**类型是最简单和最好的文档**，它们有定义明确的含义并因而提高了易读性，并且是在编译期进行检查的。
而且，严格类型化的代码通常也能更好地进行优化。

##### 示例，请勿这样做

考虑：

```c++
void pass(void* data);    // 使用弱的并且缺乏明确性的类型 void* 是有问题的
```

调用者**无法确定它允许使用哪些类型**，而且因为它并没有指定 `const`，
也**不确定其数据是否会被改动**。注意，**任何指针类型都可以隐式转换**为 `void*`，
因此调用者很容易提供这样的值给它。

被调用方必须以 `static_cast` 将数据强制转换为某个无验证的类型以使用它。
这样做易于犯错，而且啰嗦。

应当**仅在设计中无法以 C++ 来予以描述的数据的传递时**才使用 `const void*`。请考虑**使用 `variant`** 或**指向基类的指针**来代替它。

**替代方案**: 通常，利用**模板形参**可以把 `void*` 排除而改为 `T*` 或者 `T&`。
对于泛型代码，这些个 `T` 可以是一般模板参数或者是概念约束的模板参数。

##### 示例，不好

考虑：

```c++
draw_rect(100, 200, 100, 500); // 这些数值什么意思？

draw_rect(p.x, p.y, 10, 20); // 10 和 20 的单位是什么？
```

很明显调用者在描述一个矩形，不明确的是它们都和其哪些部分相关。而且 `int` 可以表示任何形式的信息，包括各种不同单位的值，因此我们必须得**猜测这四个 `int` 的含义**。前两个很可能代表坐标对偶 `x` 和 `y`，但后两个是什么呢？

注释和参数的名字可以有所帮助，但我们可以直截了当：

```c++
void draw_rectangle(Point top_left, Point bottom_right);
void draw_rectangle(Point top_left, Size height_width);

draw_rectangle(p, Point{10, 20});  // 两个角点
draw_rectangle(p, Size{10, 20});   // 一个角和一对 (height, width)
```

显然，我们是无法利用静态类型系统识别所有的错误的，
例如，假定第一个参数是左上角这一点就依赖于约定（命名或者注释）。

##### 示例，不好

考虑：

```c++
set_settings(true, false, 42); // 这些数值什么意思？
```

各参数类型及其值并**不能表明**其所指定的设置项是什么以及它们的**值所代表的含义**。

下面的设计则更加明确，安全且易读：

```c++
alarm_settings s{};
s.enabled = true;
s.displayMode = alarm_settings::mode::spinning_light;
s.frequency = alarm_settings::every_10_seconds;
set_settings(s);
```

对于**一组布尔值**的情况，可以考虑使用**某种标记枚举**；这是一种用于表示一组布尔值的模式。

```c++
enable_lamp_options(lamp_option::on | lamp_option::animate_state_transitions);
```

##### 示例，不好

下例中，接口中并未明确给出 `time_to_blink` 的含义：**按秒还是按毫秒算**？

```c++
void blink_led(int time_to_blink) // 不好 -- 在单位上含糊
{
    // ...
    // 对 time_to_blink 做一些事
    // ...
}

void use()
{
    blink_led(2);
}
```

##### 示例，好

`std::chrono::duration` 类型（C++11）可以让时间段的**单位明确**下来。

```c++
void blink_led(milliseconds time_to_blink) // 好 -- 单位明确
{
    // ...
    // 对 time_to_blink 做一些事
    // ...
}

void use()
{
    blink_led(1500ms);
}
```

这个函数还可以写成使其接受任何时间段单位的形式。

```c++
template<class rep, class period>
void blink_led(duration<rep, period> time_to_blink) // 好 -- 接受任何单位
{
    // 假设最小的有意义单位是毫秒
    auto milliseconds_to_blink = duration_cast<milliseconds>(time_to_blink);
    // ...
    // 对 milliseconds_to_blink 做一些事
    // ...
}

void use()
{
    blink_led(2s);
    blink_led(1500ms);
}
```

##### 强制实施

* 【简单】 报告**将 `void*` 用作参数或返回类型**的情况
* 【简单】 报告使用了**多个 `bool` 参数**的情况
* 【难于做好】 查找使用了**过多基础类型**的参数的函数。

### <a name="Ri-pre"></a>I.5: 说明前条件（如果有）

##### 理由

**在参数上**蕴含着**使它们在被调用方**中能够恰当使用的**约束关系**。

##### 示例

考虑：

```c++
double sqrt(double x);
```

这里 `x` 必须是非负数。类型系统是无法（简洁并自然地）表达这点的，因而我们得用别的方法。例如：

```c++
double sqrt(double x); // x 必须是非负数
```

一些前条件可以表示为断言。例如：

```c++
double sqrt(double x) { Expects(x >= 0); /* ... */ }
```

理想情况下，这个 `Expects(x >= 0)` 应当是 `sqrt()` 的接口的一部分，但我们无法轻易做到这点。当前，我们将之放入定义式（函数体）之中。

**参考**: `Expects()` 在 [GSL](#S-gsl) 中有说明。

##### 注解

**优先使用正式的必要条件说明**，比如 `Expects(!p);`。
如果这样不可行，就在**注释中使用文字来说明**，比如 `// 序列 [p:q) 根据 < 排序`。

##### 注解

**许多成员函数**都以某个类所保持的**不变式作为一项前条件**。
这个不变式是由构造函数所建立的，且必须在被从类之外所调用的每个成员函数的退出时重新建立。
我们并不需要对每个成员函数都说明这个不变式。

##### 强制实施

【无法强制实施】

**参见**: 有关传递指针的规则。???

### <a name="Ri-expects"></a>I.6: 优先使用 `Expects()` 来表达前条件

##### 理由

清晰地表明这个条件是一个前条件，并便于工具的利用。

##### 示例

```c++
int area(int height, int width)
{
    Expects(height > 0 && width > 0);            // 好
    if (height <= 0 || width <= 0) my_error();   // 隐晦的
    // ...
}
```

##### 注解

前条件是可以用许多方式来说明的，包括代码注释，`if` 语句，以及 `assert()`。
这些方式使其难于与普通代码之间进行区分，难于进行更新，难于利用工具来操作，而且可能具有错误的语义（你真的总是想要在调试模式中止程序而在生产运行中不做任何检查吗？）

##### 注解

前条件应当是**接口的一部分**，而不是实现的一部分，
但我们至今还没有能够做到这点的语言设施。
**一旦语言支持变为可用**（例如，参见[契约提案](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf)），我们就**将会采用前条件，后条件和断言的标准版本**。

##### 注解

`Expects()` 还可以用于在算法的中部来检查某个条件。

##### 注解

使用 `unsigned` 并**不是回避[确保非负数值](#Res-nonnegative)问题的好方法**。

##### 强制实施

【无法强制实施】 要把各种对前条件进行断言的方式都找出来是不可行的。对那些易于识别的（如 `assert()`）实例给出警告的做法，其意义在缺少语言设施的前提下是有问题的。

### <a name="Ri-post"></a>I.7: 说明后条件

##### 理由

以检测到对返回结果的误解，还可能发现实现中存在错误。

##### 示例，不好

考虑：

```c++
int area(int height, int width) { return height * width; }  // 不好
```

这里，我们（粗心大意地）遗漏了前条件的说明，因此高度和宽度必须是正数这点是不明确的。
我们也遗漏了后条件的说明，因此算法（`height * width`）对于大于最大整数的面积来说是错误的这点是不明显的。
**可能会有溢出**。
应该考虑使用：

```c++
int area(int height, int width)
{
    auto res = height * width;
    Ensures(res > 0);
    return res;
}
```

##### 示例，不好

考虑一个著名的安全性 BUG：

```c++
void f()    // 有问题的
{
    char buffer[MAX];
    // ...
    memset(buffer, 0, sizeof(buffer));
}
```

由于没有后条件来说明缓冲区应当被清零，**优化器可能会将这个看似多余的 `memset()` 调用给清除掉**：

```c++
void f()    // 有改进
{
    char buffer[MAX];
    // ...
    memset(buffer, 0, sizeof(buffer));
    Ensures(buffer[0] == 0);
}
```

##### 注解

后条件通常是在说明函数目的的代码注释中非正式地进行说明的；用 `Ensures()` 可以使之更加系统化，更加明显，并且更容易检查。

##### 注解

**后条件对于那些无法在所返回的结果中直接体现的东西来说尤其重要**，比如要说明所用的数据结构。

##### 示例

考虑一个操作 `Record` 的函数，它使用 `mutex` 来避免数据竞争条件：

```c++
mutex m;

void manipulate(Record& r)    // 请勿这样做
{
    m.lock();
    // ... 没有 m.unlock() ...
}
```

这里，我们"忘记"说明应当释放 `mutex`，因此我们搞不清楚这里 `mutex` 释放的缺失是一个 BUG 还是一种功能特性。
把**后条件说明**将使其更加明确：

```c++
void manipulate(Record& r)    // 后条件: m 在退出后是未锁定的
{
    m.lock();
    // ... 没有 m.unlock() ...
}
```

现在这个 BUG 就明显了（但仅对阅读了代码注释的人类来说）。

更好的做法是**使用 [RAII](#Rr-raii) 来在代码中保证后条件（"锁必须进行释放"）**的实施：

```c++
void manipulate(Record& r)    // 最好这样
{
    lock_guard<mutex> _ {m};
    // ...
}
```

##### 注解

理想情况下，**后条件应当在接口或声明式中说明，让使用者易于见到它们**。
只有那些**与使用者有关的后条件才应当在接口中说明**。
仅**与内部状态相关的后条件应当属于定义式或实现**。

##### 强制实施

【无法强制实施】 这是一条理念性的指导方针，一般情况下进行直接的
检查是不可行的。不过许多工具链中都有适用于特定领域的检查器，
比如**针对锁定持有情况的检查器**。

### <a name="Ri-ensures"></a>I.8: 优先使用 `Ensures()` 来表达后条件

##### 理由

清晰地**表明这个条件是一个后条件，并便于工具的利用**。

##### 示例

```c++
void f()
{
    char buffer[MAX];
    // ...
    memset(buffer, 0, MAX);
    Ensures(buffer[0] == 0);
}
```

##### 注解

后条件是可以用许多方式来说明的，包括代码注释，`if` 语句，以及 `assert()`。
这些方式使其难于与普通代码之间进行区分，难于进行更新，难于利用工具来操作，而且可能具有错误的语义。

**替代方案**: 如"**这个资源必须被释放"这样形式的后条件最好以 [RAII](#Rr-raii) 的方式来表达**。

##### 注释

理想情况下，`Ensures` 应当是接口的一部分，但我们无法轻易做到这点。
当前，我们将之放入定义式（函数体）之中。
一旦语言支持变为可用（例如，参见[契约提案](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf)），我们就将会采用前条件，后条件和断言的标准版本。

##### 强制实施

【无法强制实施】 要把各种对后条件进行断言的方式都找出来是不可行的。对那些易于识别的（如 `assert()`）实例给出警告的做法，其意义在缺少语言设施的前提下是有问题的。

### <a name="Ri-concepts"></a>I.9: 当接口是模板时，用概念来文档化其参数

##### 理由

**更严谨地说明接口，并使其在（不远的）将来可以在编译时进行检查**。

##### 示例

使用 ISO Concepts TS 风格的必要条件说明。例如：

    template<typename Iter, typename Val>
    // requires InputIterator<Iter> && EqualityComparable<ValueType<Iter>>, Val>
    Iter find(Iter first, Iter last, Val v)
    {
        // ...
    }

##### 注解

很快（可能是 2018 年），大多数编译器就有能力**检查删除了 `//` 之后的 `requires` 子句了**。
GCC 6.1 及其后版本支持概念。

**参见**: [泛型编程](#SS-GP)和[概念](#SS-concepts)。

##### 强制实施

【还无法强制实施】 当前正在对一种语言设施进行规范化。一旦这种语言设施出现，就可以对未被概念所约束（在其声明式之中或者在一个 `requires` 子句中所给出）的**并非可变数量的模板形参作出警告了**。

### <a name="Ri-except"></a>I.10: 使用异常来表明无法实施所要求的任务

##### 理由

不应该让错误可以被忽略，因为这将导致系统或者一次运算进入未定义的（或者预料之外的）状态。
这是错误的一个主要来源。

##### 示例

```c++
int printf(const char* ...);    // 不好: 当输出失败时返回负值

template <class F, class ...Args>
// 好: 当无法启动一个新的线程时抛出 system_error
explicit thread(F&& f, Args&&... args);
```

##### 注解

错误是什么？

**错误的含义是函数无法达成其所宣称的目标**（这包括后条件的建立）。
**把错误忽略掉的调用方代码将导致错误的结果，或者未定义的系统状态**。
例如，无法连接一个远程服务器本身并不是错误：
这个服务器可以因为各种原因而拒绝连接，因此合乎常理的方式是让其返回一个其调用者必然要检查的结果。
不过，如果无法连接本身就是被当作一种错误的话，这个失败时应当抛出一个异常。

##### 例外

许多传统的接口函数（比如 UNIX 的信号处理器）都使用错误代码（就是 `errno`）来报告其实是状态代码而不是错误的东西。你没有更好的选择只能用它，因此对其调用并不违反本条规则。

##### 替代方案

如果你不能使用异常（比如说由于你的代码全都是老式的原始指针用法，或者由于你有硬实时性的约束），请考虑**使用返回一对值的代码风格**：

```C++
int val;
int error_code;
tie(val, error_code) = do_something();
if (error_code) {
    // ... 处理错误或者退出 ...
}
// ... 使用 val ...
```

这种风格不幸地会**导致未初始化的变量**。
从 C++17 开始，可以使用 "结构化绑定" 功能特性来**从返回值直接对多个变量初始化**。

```C++
auto [val, error_code] = do_something();
if (error_code) {
    // ... 处理错误或者退出 ...
}
// ... 使用 val ...
```

##### 注解

我们并不认为"性能"是一种不使用异常的合理理由。

* 通常，显式的错误检查和处理会消耗掉和异常处理一样多的时间和空间。
* 通常，**使用异常的更清晰的代码会带来更好的性能**（简化了对程序执行路径的追踪和其优化）。
* 一条对性能关键代码的好规则是，**把检查从代码的关键部分中移出去**（[检查](#Rper-checking)）。
* 长期来看，更规整的代码会得到更好的优化。
* 在做出性能相关的声明前一定要小心地[进行测量](#Rper-measure)。

**参见**: [I.5](#Ri-pre) 和 [I.7](#Ri-post) 有关报告前条件和后条件的违反。

##### 强制实施

* 【无法强制实施】 这是一条理念性的指导方针，进行直接的检查是不可行的。
* 查找 `errno`。

### <a name="Ri-raw"></a>I.11: 决不以原始指针（`T*`）或引用（`T&`）来传递所有权

##### 理由

如果对调用者和被调用方**哪一个拥有对象有疑问**，那就**会造成泄漏**或者发生**提早的析构**。

##### 示例

考虑：

```C++
X* compute(args)    // 请勿这样做
{
    X* res = new X{};
    // ...
    return res;
}
```

应当由**谁来删除返回的这个 `X` 呢**？如果 `compute` 返回引用的话这个问题将更难发现。
应该考虑按值来返回结果（如果结果比较大的话就用移动语义）：

```C++
vector<double> compute(args)  // 好的
{
    vector<double> res(10000);
    // ...
    return res;
}
```

**替代方案**: 用"智能指针"来[传递所有权](#Rr-smartptrparam)，比如 `unique_ptr`（专有所有权）和 `shared_ptr`（共享所有权）。
这样做比返回对象自身来说并没有那么简炼，而且通常也不那么高效，
**因此，仅当需要引用语义时再使用智能指针**。

**替代方案**: 有时候因为 ABI 兼容性的要求或者缺少资源，是无法对老代码进行修改的。
这种情况下，**请用[指导方针支持库](#S-gsl)的 `owner` 来标记拥有对象的指针**：

```C++
owner<X*> compute(args)    // 现在就明确传递了所有权这一点
{
    owner<X*> res = new X{};
    // ...
    return res;
}
```

这告诉了分析工具 `res` 是一个所有者。
就是说，它的值必须被 `delete`，或者被传递给另一个所有者，正如这里的 `return` 所做。

**在资源包装类的实现中也同样使用了 `owner`。**

##### 注解

以原始指针（或迭代器）的形式传递的对象，**都假定是由调用方所有的**，因此其生存期也由调用方来处理。换种方式来看：
**传递所有权的 API 相对于传递指针的 API 来说比较少见**，
因此缺省情况就是"不传递所有权"。

**参见**: [实参传递](#Rf-conventional)，[使用智能指针参数](#Rr-smartptrparam)，以及[返回值](#Rf-value-return)。

##### 强制实施

* 【简单】 当对并非 `owner<T>` 的原始指针进行 `delete` 就发出警告。**建议使用标准库的资源包装或者使用 `owner<T>`**。
* 【简单】 当任何代码路径上**遗漏**了对 `owner` 指针的 **`reset`** 或者**显式的 `delete` 时就发出警告**。
* 【简单】 当把 `new` 或者返回值为 **`owner` 的函数**的返回值**赋值给原始指针**或**非 `ower` 的引用**时就发出警告。

### <a name="Ri-nullptr"></a>I.12: 把不能为空的指针声明为 `not_null`

##### 理由

帮助**避免对 `nullptr` 解引用**的错误。
通过**避免多余的 `nullptr` 检查**来提高性能。

##### 示例

```C++
int length(const char* p);            // 不清楚 length(nullptr) 是否有效

length(nullptr);                      // OK?

int length(not_null<const char*> p);  // 有改善：可以假定 p 不可能为 nullptr

int length(const char* p);            // 只好假定 p 可以为 nullptr
```

通过在源代码中说明意图，实现者和工具就可以提供更好的诊断能力，比如通过静态分析来找出某些种类的错误，还可以实施优化，比如移除分支和空值测试。

##### 注解

`not_null` 在[指导方针支持库](#S-gsl)中定义。

##### 注解

指向 `char` 的指针将指向 C 风格的字符串（以**零终结的字符的连续串**）这一点仍然是潜规则，并且也是混乱和错误的潜在来源。**请使用 `czstring` 来代替 `const char*`**。

```C++
// 可以假定 p 不能为 nullptr
// 可以假定 p 指向以零终结的字符数组
int length(not_null<zstring> p);
```

注意： `length()` 显然是经过伪装的 `std::strlen()`。

##### 强制实施

* 【简单】〔基础〕 如果有函数在所有控制流路径上访问指针参数之前检查它是否是 `nullptr`，则给出警告称其**应当被声明为 `not_null`**。
* 【复杂】 如果有**指针返回值的函数**在所有返回路径上都保证其不是 `nullptr`，则给出警告称返回类型**应当被声明为 `not_null`**。

### <a name="Ri-array"></a>I.13: 不要只用一个指针来传递数组

##### 理由

 **(pointer, size) 式的接口是易于出错的**。同样，（指向数组的）**普通指针还必须依赖**某种约定以使被调用方来确定**其大小**。

##### 示例

考虑：

```C++
void copy_n(const T* p, T* q, int n); // 从 [p:p+n) 复制到 [q:q+n)
```

当由 `q` 所指向的数组少于 `n` 个元素会怎么样？此时我们将**覆写一些可能无关**的内存。
当由 `p` 所指向的数组少于 `n` 个元素会怎么样？此时我们将**读取一些可能无关**的内存。
次二者都是未定义的行为，而且可能是非常恶劣的 BUG。

##### 替代方案

考虑使用明确的 `span`：

```C++
void copy(span<const T> r, span<T> r2); // 将 r 复制给 r2
```

##### 示例，不好

考虑：

```C++
void draw(Shape* p, int n);  // 糟糕的接口；糟糕的代码
Circle arr[10];
// ...
draw(arr, 10);
```

把 `10` 作为参数 `n` 传递可能是错误的：虽然最常见的约定是假定有 `[0:n)`，但这点并未不是明确的。更糟糕的是，`draw()` 的调用通过编译了：这里有一次从数组到指针的隐式转换（数组衰退），然后又进行了从 `Circle` 到 `Shape` 的另一次隐式转换。**`draw()` 是不可能安全地迭代这个数组的：它无法知道元素的大小**。

**替代方案**: 使用一个**辅助类来确保元素的数量正确**，并避免进行危险的隐式转换。例如：

```C++
void draw2(span<Circle>);
Circle arr[10];
// ...
draw2(span<Circle>(arr));  // 推断出元素的数量
draw2(arr);    // 推断出元素的类型和数组大小

void draw3(span<Shape>);
draw3(arr);    // 错误: 无法将 Circle[10] 转换为 span<Shape>
```

这个 `draw2()` 传递了与 `draw()` 同样数量的信息，但明确指定了它接受的是 `Circle` 的范围。参见 ???.

##### 例外

使用 `zstring` 和 `czstring` 来表示 **C 风格的以零终结字符串**。
但这样做时，应当使用 `std::string_view` 或 [GSL](#GSL) 中的 `string_span` 以**避免范围错误**。

##### 强制实施

* 【简单】〔边界〕 对任何依赖于从**数组类型向指针类型的隐式转换**的表达式给出警告。允许 zstring/czstring 指针类型的例外。
* 【简单】〔边界〕 **对任何指针类型表达式进行且结果为指针类型的值的运算操作给出警告**。允许 zstring/czstring 指针类型的例外。

### <a name="Ri-global-init"></a>I.22: 避免全局对象之间进行复杂的初始化

##### 理由

复杂的初始化可能导致未定义的执行顺序。

##### 示例

```c++
// file1.c

extern const X x;

const Y y = f(x);   // 读取 x; 写入 y

// file2.c

extern const Y y;

const X x = g(y);   // 读取 y; 写入 x
```

由于 `x` 和 `y` 是处于不同编译单元之内的，调用 `f()` 和 `g()` 的顺序就是未定义的；
我们可能会访问到还未初始化的 `const` 对象。
这里展示的是，全局（命名空间作用域）对象的初始化顺序难题并不仅限于全局*变量*而已。

##### 注解

并发代码中的**初始化顺序问题**是更加难于处理的。
所以通常最好完全**避免使用全局**（命名空间作用域）的对象。

##### 强制实施

* 标记调用了非 `constexpr` 函数的全局初始化式
* 标记访问了 `extern` 对象的全局初始化式

### <a name="Ri-nargs"></a>I.23: 保持较少的函数参数数量

##### 理由

**大量参数会带来更大的出现混乱的机会**。大量传递参数与其他替代方案相比也通常是代价比较大的。

##### 讨论

两个最常见的使得函数具有**过多参数的原因**是：

1. *缺乏抽象*
   缺少一种抽象，使得一个**组合值被以一组独立的元素的方式进行传递**，而不是以一个单独的保证了不变式的对象来传递。
   这不仅使其参数列表变长，而且会导致错误，因为各个成分值无法再被某种获得保证的不变式进行保护。
   
2. *违反了"函数单一职责"原则*
   这个**函数试图完成多项任务**，它可能应当被重构。

##### 示例

标准库的 `merge()` 函数达到了我们可以自如处理的界限：

```c++
template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result, Compare comp);
```

注意，这属于上面的第一种问题：缺乏抽象。STL 传递的不是范围（抽象），而是一对迭代器（未封装的成分值）。

其中有四个模板参数和留个函数参数。
为简化最常用和最简单的用法，比较器参数可以缺省使用 `<`：

```c++
template<class InputIterator1, class InputIterator2, class OutputIterator>
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result);
```

这实际上不会减低其整体复杂性，但它减少了对于许多使用者的表面复杂性。
为了真正地减少参数的数量，我们得把参数归拢到更高层的抽象之中：

```c++
template<class InputRange1, class InputRange2, class OutputIterator>
OutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result);
```

把**参数成"批"进行组合**是减少参数数量和增加进行检查的机会的一般性技巧。

或者，我们也可以用概念（如 ISO TS 所定义）来定义这三个类型必须可以用于进行合并：

```c++
Mergeable{In1, In2, Out}
OutputIterator merge(In1 r1, In2 r2, Out result);
```

##### 示例

安全性剖面配置中建议将以下代码

```c++
void f(int* some_ints, int some_ints_length);  // 不好：C 风格，不安全
```

替换为

```c++
void f(gsl::span<int> some_ints);              // 好：安全，有边界检查
```

这样，使用一种**抽象可以获得安全性和健壮性的好处**，而且自然地减少了参数的数量。

##### 注解

多少参数算很多？**请使用少于四个参数**。
有些函数确实最好表现为四个独立的参数，但这样的函数并不多。

**替代方案**: 使用更好的抽象：把**参数归集为由意义的对象**，然后（**按值或按引用**）传递这些对象。

**替代方案**: 利用**默认实参**或者**重载**来让最常见的调用方式可以用比较少的实参来进行。

##### 强制实施

* 当函数声明了**两个类型相同的迭代器**（也包括指针）而**不是一个范围或视图**，就给出**警告**。
* 【无法强制实施】 这是一条理念性的指导方针，进行直接的检查是不可行的。

### <a name="Ri-unrelated"></a>I.24: 避免出现相邻而无关的相同类型的参数

##### 理由

**相同类型的相邻参数很容易被不小心互换掉**。

##### 示例，不好

考虑：

```c++
void copy_n(T* p, T* q, int n);  // 从 [p:p + n) 复制到 [q:q + n)
```

这是个 K&R C 风格接口的一种恶劣的变种。它导致很容易把"目标"和"来源"参数搞反。

可以**在"来源"参数上使用 `const`：**

```c++
void copy_n(const T* p, T* q, int n);  // 从 [p:p + n) 复制到 [q:q + n)
```

##### 例外

当参数的顺序不重要时，不会造成问题：

```c++
int max(int a, int b);
```

##### 替代方案

**不要以指针来传递数组**，而**要传递用来表示一个范围的对象**（比如一个 `span`）：

```c++
void copy_n(span<const T> p, span<T> q);  // 从 p 复制到 q
```

##### 替代方案

定义**一个 `struct` 来作为参数**类型，并依照各个参数来命名它的各字段：

```c++
struct SystemParams {
    string config_file;
    string output_path;
    seconds timeout;
};
void initialize(SystemParams p);
```

这样做带来一种使其调用代码对于以后的读者变得明晰的倾向，因为这种参数
在调用点通常都要按名字来进行填充。

##### 强制实施

【简单】 当两个连续的参数具有相同的类型时就给出警告。

### <a name="Ri-abstract"></a>I.25: 优先以抽象类作为类层次的接口

##### 理由

**抽象类**要比带有状态的基类更倾向于**保持稳定**。

##### 示例，不好

你知道 `Shape` 总会冒出来的 :-)

```c++
class Shape {  // 不好: 接口类中加载了数据
public:
    Point center() const { return c; }
    virtual void draw() const;
    virtual void rotate(int);
    // ...
private:
    Point c;
    vector<Point> outline;
    Color col;
};
```

这将强制性要求每个派生类都要计算出一个中心点——即使这并不容易，而且这个中心点从不会被用到。相似地说，不是每个 `Shape` 都有一个 `Color`，而许多 `Shape` 也最好别用一个定义成一系列 `Point` 的轮廓来进行表示。**抽象类就是为了防止人们编写这样的类而创造出来的**：

```c++
class Shape {    // 有改进: Shape 是一个纯接口
public:
    virtual Point center() const = 0;   // 纯虚函数
    virtual void draw() const = 0;
    virtual void rotate(int) = 0;
    // ...
    // ... 没有数据成员 ...
    // ...
    virtual ~Shape() = default;        
};
```

##### 强制实施

【简单】 当把类 `C` 的指针/引用赋值给 `C` 的某个基类的指针/引用，而这个**基类包含数据成员时，就给出警告**。

### <a name="Ri-abi"></a>I.26: 当想要跨编译器的 ABI 时，使用一个 C 风格的语言子集

##### 理由

**不同的编译器会实现不同的****类的二进制布局**，异常处理，函数名字，以及其他的实现细节。

##### 例外

在一些平台上**正有公共的 ABI 兴起，这可以使你从更加苛刻的限制**中摆脱出来。

##### 注解

如果你**只用一种编译器，你也可以在接口上使用完全的 C++**。但当**升级到新的编译器**版本之后，可能需要进行重新编译。

##### 强制实施

【无法强制实施】 要可靠地识别某个接口是否是构成 ABI 的一部分是很困难的。

### <a name="Ri-pimpl"></a>I.27: 对于稳定的程序库 ABI，考虑使用 Pimpl 手法

##### 理由

由于私有数据成员参与类的内存布局，而私有成员函数参与重载决议，
对这些**实现细节的改动都要求使用了这类的所有用户全部重新编译**。而**持有指向实现的指针（Pimpl）的**
**非多态的接口类**，则可以将类的用户从其实现的改变隔离开来，其代价是一层间接。

##### 示例

接口（widget.h）

```c++
class widget {
    class impl;
    std::unique_ptr<impl> pimpl;
public:
    void draw(); // 公开 API 转发给实现
    widget(int); // 定义于实现文件中
    ~widget();   // 定义于实现文件中，其中 impl 将为完整类型
    widget(widget&&) = default;
    widget(const widget&) = delete;
    widget& operator=(widget&&); // 定义于实现文件中
    widget& operator=(const widget&) = delete;
};
```


实现（widget.cpp）

```c++
class widget::impl {
    int n; // private data
public:
    void draw(const widget& w) { /* ... */ }
    impl(int n) : n(n) {}
};
void widget::draw() { pimpl->draw(*this); }//多态实现
widget::widget(int n) : pimpl{std::make_unique<impl>(n)} {}
widget::~widget() = default;
widget& widget::operator=(widget&&) = default;
```

##### 注解

参见 [GOTW #100](https://herbsutter.com/gotw/_100/) 和 [cppreference](http://en.cppreference.com/w/cpp/language/pimpl) 有关这个手法相关的权衡和其他实现细节。

##### 强制实施

【无法强制】 很难可靠地识别出哪个接口属于 ABI 的一部分。

### <a name="Ri-encapsulate"></a>I.30: 将有违规则的部分封装

##### 理由

**维持代码简单且安全**。
有时候因为逻辑的或者性能的原因，需要使用**难看的，不安全的或者易错的技术**。
此时，将**它们局部化**，而不是使其"感染"接口，可以避免更多的程序员团队必须当心其
细节和微妙之处。
如果可能的话，实现复杂度不能通过接口渗透到用户代码之中。

##### 示例

考虑一个程序，其基于某种形式的输入（比如 `main` 的实参）来决定
从文件，从命令行，还是从标准输入来获得输入数据。
我们可能会将其写成

```c++
bool owned;
owner<istream*> inp;
switch (source) {
case std_in:        owned = false; inp = &cin;                       break;
case command_line:  owned = true;  inp = new istringstream{argv[2]}; break;
case file:          owned = true;  inp = new ifstream{argv[2]};      break;
}
istream& in = *inp;
```

这违反了[避免未初始化变量](#Res-always)，
[避免忽略所有权](#Ri-raw)，
和[避免魔法常量](#Res-magic)等规则。
尤其是，人们必须记得找地方写

```c++
if (owned) delete inp;
```

我们可以通过使用带有一个特殊的删除器（对 `cin` 不做任何事）的 `unique_ptr` 来处理这个特定的例子，
但这对于新手来说较复杂（他们很容易遇到这种问题），并且这个例子其实是一个更一般的问题的特例：
我们希望将其当做静态的某种属性（此处为所有权），需要在运行时进行偶尔的处理。
一般的，更常见的，且更安全的例子可以被静态处理，因而我们并不希望为它们添加开销和复杂性。
然而我们还是不得不处理那些不常见的，较不安全的，而且更为昂贵的情况。
[[Str15]](http://www.stroustrup.com/resource-model.pdf) 中对这种例子有所探讨。

由此，我们编写这样的类

```c++
class Istream { [[gsl::suppress(lifetime)]]
public:
    enum Opt { from_line = 1 };
    Istream() { }
    Istream(zstring p) :owned{true}, inp{new ifstream{p}} {}            // 从文件读取
    Istream(zstring p, Opt) :owned{true}, inp{new istringstream{p}} {}  // 从命令行读取
    ~Istream() { if (owned) delete inp; }
    operator istream& () { return *inp; }
private:
    bool owned = false;
    istream* inp = &cin;
};
```

这样，`istream` 的所有权的动态本质就被封装起来。
大体上，在现实的代码中还是需要针对潜在的错误添加一些检查。

##### 强制实施

* 很难，判断那种违背规则的代码是基本的是很难做到的
* 对允许规则违背的部分跨越接口的规则抑制进行标记

# <a name="S-functions"></a>F: 函数

**函数**指定了一个活动或者一次计算，以将系统从一种一致的**状态转移**到另一种一致的状态。函数是程序的基础构造块。

应当使函数的名字有意义，说明对其参数的必要条件，并清晰地规定参数和其结果之间的关系。函数的实现本身并不是规格说明。请尝试同时对函数应当做什么和函数应当怎样做来进行思考。
**函数在大多数接口中都是最关键的部分**，请参考接口的规则。

函数规则概览：

函数定义式的规则：

* [F.1: 把有意义的操作"打包"成为精心命名的函数](#Rf-package)
* [F.2: 一个函数应当实施单一一项逻辑操作](#Rf-logical)
* [F.3: 保持函数短小简洁](#Rf-single)
* [F.4: 如果函数必须在编译期进行求值，就将其声明为 `constexpr`](#Rf-constexpr)
* [F.5: 如果函数非常小，并且是时间敏感的，就将其声明为 `inline`](#Rf-inline)
* [F.6: 如果函数不会抛出异常，就将其声明为 `noexcept`](#Rf-noexcept)
* [F.7: 对于常规用法，应当接受 `T*` 或 `T&` 参数而不是智能指针](#Rf-smart)
* [F.8: 优先采用纯函数](#Rf-pure)
* [F.9: 未使用的形参应当没有名字](#Rf-unused)

参数传递表达式的规则：

* [F.15: 优先采用简单的和传统的信息传递方式](#Rf-conventional)
* [F.16: 对于"输入（in）"参数，把复制操作廉价的类型按值进行传递，把其他类型按 `const` 引用进行传递](#Rf-in)
* [F.17: 对于"输入/输出（in-out）"参数，按非 `const` 引用进行传递](#Rf-inout)
* [F.18: 对于"将被移动（will-move-from）"参数，按 `X&&` 进行传递并对参数 `std::move`](#Rf-consume)
* [F.19: 对于"转发（forward）"参数，按 `TP&&` 进行传递并只对参数 `std::forward`](#Rf-forward)
* [F.20: 对于"输出（out）"值，采用返回值优先于输出参数](#Rf-out)
* [F.21: 要返回多个"输出"值，优先返回结构体或元组（tuple）](#Rf-out-multi)
* [F.60: 当"没有参数"是有效的选项时，采用 `T*` 优先于 `T&`](#Rf-ptr-ref)

参数传递语义的规则：

* [F.22: 用 `T*` 或 `owner<T*>` 来代表单个对象](#Rf-ptr)
* [F.23: 用 `not_null<T>` 来表明"空值（null）"不是有效的值](#Rf-nullptr)
* [F.24: 用 `span<T>` 或者 `span_p<T>` 来代表一个半开序列](#Rf-range)
* [F.25: 用 `zstring` 或者 `not_null<zstring>` 来代表 C 风格的字符串](#Rf-zstring)
* [F.26: 当需要指针时，用 `unique_ptr<T>` 来传递所有权](#Rf-unique_ptr)
* [F.27: 用 `shared_ptr<T>` 来共享所有权](#Rf-shared_ptr)

<a name="Rf-value-return"></a>值返回语义的规则：

* [F.42: 返回 `T*` 来（仅仅）给出一个位置](#Rf-return-ptr)
* [F.43: 不要（直接或间接）返回指向局部对象的指针或引用](#Rf-dangle)
* [F.44: 当不想进行复制，且不需要"没有对象被返回"时，返回 `T&`](#Rf-return-ref)
* [F.45: 不要返回 `T&&`](#Rf-return-ref-ref)
* [F.46: `int` 是 `main()` 的返回类型](#Rf-main)
* [F.47: 赋值运算符返回 `T&`](#Rf-assignment-op)
* [F.48: 不要用 `return std::move(local)`](#Rf-return-move-local)

其他函数规则：

* [F.50: 当函数不适用时（不能俘获局部变量，或者不能编写局部函数），就使用 Lambda](#Rf-capture-vs-overload)
* [F.51: 如果需要作出选择，采用默认实参应当优先于进行重载](#Rf-default-args)
* [F.52: 对于局部使用的（也包括传递给算法的）lambda，优先采用按引用俘获](#Rf-reference-capture)
* [F.53: 对于非局部使用的（包括被返回的，在堆上存储的，或者传递给别的线程的）lambda，避免采用按引用俘获](#Rf-value-capture)
* [F.54: 当俘获了 `this` 时，显式俘获所有的变量（不使用默认俘获）](#Rf-this-capture)
* [F.55: 不要使用 `va_arg` 参数](#F-varargs)

函数和 Lambda 表达式以及函数对象有很强的相似性。

**参见**：[C.lambdas: 函数对象和 lambda](#SS-lambdas)

## <a name="SS-fct-def"></a>F.def: 函数的定义式

函数的定义式就是一并指定了函数的实现（函数体）的函数声明式。

### <a name="Rf-package"></a>F.1: 把有意义的操作"打包"成为精心命名的函数

##### 理由

**把公共的代码分解出去，将使代码更易于阅读，更可能被重用**，并能够对源于复杂代码的错误有所限制。
如果某部分是一个明确指定的活动，就将之从其包围代码中分离出来，并为其进行命名。

##### 示例，请勿这样做

```c++
void read_and_print(istream& is)    // 读取并打印一个 int
{
    int x;
    if (is >> x)
        cout << "the int is " << x << '\n';
    else
        cerr << "no int on input\n";
}
```

`read_and_print` 的几乎每件事都有问题。
它进行了读取，它（向一个固定 `ostream`）进行了写入，它（向一个固定的 `ostream`）写入了错误消息，它只能处理 `int`。
这里没有可以重用的东西，逻辑上分开的操作被搅拌到了一起，而局部变量在其逻辑上使用完毕之后仍处于作用域中。
作为一个小例子的话还好，但如果输入操作、输出操作和错误处理更加复杂的话，
这个纠缠混乱的代码就会变得难于理解了。

##### 注解

如果你编写的一个**有些价值的 lambda 可能潜在地被用于多处，那就为它进行命名并将其赋值给一个（通常非局部的）变量**。

##### 示例

```c++
sort(a, b, [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); });
```

对 lambda 进行命名，将会把这个表达式进行逻辑上的分解，还会为 lambda 的含义给出有力的提示。

```c++
auto lessT = [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); };

sort(a, b, lessT);
find_if(a, b, lessT);
```

对于性能和可维护性来说，最简短的代码并不总是最好的选择。

##### 例外

循环体，包括用作循环体的 lambda，很少需要进行命名。
然而，大型的循环体（比如好多行或者好多页）也是个问题。
规则"[保持函数短小简洁](#Rf-single)"暗含有"**保持循环体短小**"。
与此相似，用作回调参数的 lambda 有事后也是有意义的，虽然它们不大可能被重用。

##### 强制实施

* 参见"[保持函数短小简洁](#Rf-single)"
* 把不同地方所用的**同样**和非常**相似**的 **lambda 标记**出来。

### <a name="Rf-logical"></a>F.2: 一个函数应当实施单一一项逻辑操作

##### 理由

仅实施**单一操作的函数易于理解，测试和重用**。

##### 示例

考虑：

```c++
void read_and_print()    // 不好
{
    int x;
    cin >> x;
    // 检查错误
    cout << x << "\n";
}
```

这是一整块被绑定到一个特定的输入的代码，而且无法为其找到另一种（不同的）用途。作为代替，我们把函数分解为合适的逻辑部分并进行参数化：

```c++
int read(istream& is)    // 有改进
{
    int x;
    is >> x;
    // 检查错误
    return x;
}

void print(ostream& os, int x)
{
    os << x << "\n";
}
```

这样的话，就可以在需要时进行组合：

```c++
void read_and_print()
{
    auto x = read(cin);
    print(cout, x);
}
```

如果有需要，我们还可以进一步把 `read()` 和 `print()` 针对数据类型，I/O 机制，以及对错误的反应等等方面进行**模板化**。例如：

```c++
auto read = [](auto& input, auto& value)    // 有改善
{
    input >> value;
    // 检查错误
};

auto print(auto& output, const auto& value)
{
    output << value << "\n";
}
```

##### 强制实施

* 把具有**多个"输出"参数的函数当作有问题**的。使用返回值来代替，包括**以 `tuple` 用作多个返回值**。
* 把无法装入编辑器的一屏之内的**"大型"函数当作有问题**的。考虑把这种函数分解为较小的恰当命名的子操作。
* 把有七个或更**多参数的函数当作有问题的**。

### <a name="Rf-single"></a>F.3: 保持函数短小简洁

##### 理由

**大型函数难于阅读，更有可能包含复杂的代码**，而且更有可能含有其作用域超过最低限度的变量。
带有**复杂的控制结构的函数更有可能变长**，也更有**可能隐藏逻辑错误**于其中。

##### 示例

考虑：

```c++
double simple_func(double val, int flag1, int flag2)
    // simple_func: 接受一个值并计算所需的 ASIC 值，
    // 依赖于两个模式标记。
{
    double intermediate;
    if (flag1 > 0) {
        intermediate = func1(val);
        if (flag2 % 2)
             intermediate = sqrt(intermediate);
    }
    else if (flag1 == -1) {
        intermediate = func1(-val);
        if (flag2 % 2)
             intermediate = sqrt(-intermediate);
        flag1 = -flag1;
    }
    if (abs(flag2) > 10) {
        intermediate = func2(intermediate);
    }
    switch (flag2 / 10) {
    case 1: if (flag1 == -1) return finalize(intermediate, 1.171);
            break;
    case 2: return finalize(intermediate, 13.1);
    default: break;
    }
    return finalize(intermediate, 0.);
}
```

这个函数过于复杂了。
要如何判断是否所有的可能性都被正确处理了呢？
当然，它也同样违反了别的规则。

我们可以进行重构：

```c++
double func1_muon(double val, int flag)
{
    // ???
}

double func1_tau(double val, int flag1, int flag2)
{
    // ???
}

double simple_func(double val, int flag1, int flag2)
    // simple_func: 接受一个值并计算所需的 ASIC 值，
    // 依赖于两个模式标记。
{
    if (flag1 > 0)
        return func1_muon(val, flag2);
    if (flag1 == -1)
        // 由 func1_tau 来处理: flag1 = -flag1;
        return func1_tau(-val, flag1, flag2);
    return 0.;
}
```

##### 注解

"无法放入一屏显示"通常是对"太长了"的一种不错的实际定义方式。
**一行到五行大小的函数应当被当作是常态**。

##### 注解

把**大型函数分解成较小**的紧致的有名字的函数。
**小型的简单函数**在函数调用的代价比较明显时**很容易被内联**。

##### 强制实施

* 标记无法"放入一屏"的函数。
  一屏有多大？**可以试试 60 行，每行 140 个字符**；这大致上就是书本页面能够适于阅读的最大值了。
* 标记过于复杂的函数。多复杂算是过于复杂呢？
  **应当用圈复杂度来度量**。可以试试"多于 10 个逻辑路径"。一个简单的开关算作一条路径。

### <a name="Rf-constexpr"></a>F.4: 如果函数必须在编译期进行求值，就将其声明为 `constexpr`

##### 理由

需要用 `constexpr` 来告诉编译器允许对其进行编译期求值。

##### 示例

（不）著名的阶乘例子：

```c++
constexpr int fac(int n)
{
    constexpr int max_exp = 17;      // constexpr 使得可以在 Expects 中使用 max_exp
    Expects(0 <= n && n < max_exp);  // 防止犯糊涂和发生溢出
    int x = 1;
    for (int i = 2; i <= n; ++i) x *= i;
    return x;
}
```

这个是 C++14。
对于 C++11，请使用递归形式的 `fac()`。

##### 注解

`constexpr` 并不会保证发生编译期求值；
它只能保证函数可以在当程序员需要或者编译器为优化而决定时，对常量表达式实参进行编译期求值。

```c++
constexpr int min(int x, int y) { return x < y ? x : y; }

void test(int v)
{
    int m1 = min(-1, 2);            // 可能进行编译期求值
    constexpr int m2 = min(-1, 2);  // 编译期求值
    int m3 = min(-1, v);            // 运行期求值
    constexpr int m4 = min(-1, v);  // 错误: 无法在编译期求值
}
```

##### 注解

**不要试图让所有函数都变成 `constexpr`**。
**大多数计算都最好在运行时进行**。

##### 注解

任何可能最终将**依赖于高层次的运行时配置或者业务逻辑的API，都不应当是 `constexpr` 的**。这种定制化是无法由编译期来求值的，并且依赖于这种 API 的任何 `constexpr` 函数也都应当进行重构，或者抛弃掉 `constexpr`。

##### 强制实施

不可能也不必要。
当在**要求常量的地方调用了非 `constexpr` 函数**时，编译器会报告错误。

### <a name="Rf-inline"></a>F.5: 如果函数非常小，并且是时间敏感的，就将其声明为 `inline`

##### 理由

有些优化器可以不依赖于程序员的提示就能很好地进行内联，但请不要依赖这点。
请测量！至少超过 40 年，我们一直在允诺编译器可以不依赖于人类的提示而做到比人类更好地内联。
可是我们还在等。
**给出 `inline` 能够促进编译器更好地工作**。

##### 示例

    inline string cat(const string& s, const string& s2) { return s + s2; }

##### 例外

**不要把 `inline` 函数加入需要变得稳定的接口中**，除非你十分确定它不会再发生变化。
内联函数是 ABI的一部分。

##### 注解

**`constexpr` 蕴含 `inline`。**

##### 注解

在类之中所定义的**成员函数默认是 `inline` 的**。

##### 例外

**模板函数**（包括模板成员函数）**一般都定义于头文件中，因此是内联的**。

##### 强制实施

**对超过三条语句，并且本可以声明为非内联**的 `inline` 函数（比如类成员函数）标记为 `inline`。

### <a name="Rf-noexcept"></a>F.6: 如果函数不会抛出异常，就将其声明为 `noexcept`

##### 理由

如果**不打算抛出异常**的话，程序就会认为无法处理这种错误，并且**应当尽早终止**。把**函数声明为 `noexcept`** 对优化器有好处，因为其减少了可能的执行路径的数量。它也能使发生故障之后的退出动作有所加速。

##### 示例

给**完全以 C 或者其他任何没有异常的语言编写的每个函数都标上 `noexcept`**。
C++ 标准库隐含地对 C 标准库中的所有函数做了这件事。

##### 注解

**`constexpr` 函数在运行时执行时可能抛出异常**，因此可能需要对其中的一些使用 `noexcept`。

##### 示例

对能够抛出异常的函数**也可以使用 `noexcept`**：

```c++
vector<string> collect(istream& is) noexcept
{
    vector<string> res;
    for (string s; is >> s;)
        res.push_back(s);
    return res;
}
```

如果 `collect()` 耗光了内存，程序就会崩溃。
除非这个程序特别精心编写成不会耗尽内存，否则这可能正是正确的方式；
**`terminate()` 能够产生合适的错误日志信息**（但**当内存耗尽时是很难做出**任何巧妙的事情的）。

##### 注解

当你想决定是否要给函数标上 `noexcept` 时，一定要特别注意你的代码的执行环境，尤其是与**抛出异常和内存分配相关的情形**。打算成为**完全通用的代码**（比如像标准库和其他类似的工具代码），应当**支持那些有意义地处理了 `bad_alloc` 异常**的执行环境。
不过，大多数程序和执行环境都不能有意义地处理内存分配失败，而中止程序则是在这些情况中应对分类失败的最干净和最简单的方式。如果已知应用程序代码无法应对分配失败的话，对于即使确实会进行分配的函数，添加 `noexcept` 也是适当的。

换一种方式来说：在大多数程序中，大多数函数都会抛出异常（比如说，它们可能使用 `new`，调用会抛出异常的函数，或者使用通过抛出异常来报告失败的库函数），因此请勿随意到处散布 `noexcept` 而不考虑清楚是否有异常是可以被处理的。

**`noexcept` 对于常用的，底层的函数是最有用处的**（并且几乎显然是正确的）。

##### 注解

**析构函数，`swap` 函数，移动操作，以及默认构造函数不应当抛出异常**。
另请参见 [C.44](#Rc-default00)。

##### 强制实施

* 标记不是 `noexcept`，而又不能抛出异常的函数。
* 标记抛出异常的 `swap`，`move`，析构函数，以及默认构造函数。

### <a name="Rf-smart"></a>F.7: 对于常规用法，应当接受 `T*` 或 `T&` 参数而不是智能指针

##### 理由

**智能指针的传递会转移或者共享所有权**，因此应当仅在有意要实现所有权语义时才能使用（参见 [R.30](#Rr-smartptrparam)）。
使用按智能指针传递方式**把函数限制为只能服务于使用智能指针的调用方**。
智能指针的传递（比如 `std::shared_ptr`）**暗含了一些运行时成本**。

##### 示例

```C++
// 接受任何的 int*
void f(int*);

// 只能接受你想转移所有权的 int
void g(unique_ptr<int>);

// 只能接受你想共享所有权的 int
void g(shared_ptr<int>);

// 不会改变所有权，但要求调用方对其具有特定的所有权。
void h(const unique_ptr<int>&);

// 接受任何的 int
void h(int&);
```

##### 示例，不好

```C++
// 被调用方
void f(shared_ptr<widget>& w)
{
    // ...
    use(*w); // w 的唯一使用点 -- 其生存期是完全未被涉及到的
    // ...
};
```

进一步请参见 [R.30](#Rr-smartptrparam)。

##### 注解

**悬挂指针是可以静态地找出来的**，因此我们并不需要依靠资源管理功能来避免悬挂指针。

**参见**

* [当"无实参"是有效情形时，优先采用 `T*` 而不是 `T&`](#Rf-ptr-ref)
* [智能指针规则概述](#Rr-summary-smartptrs)

##### 强制实施

**标记并未使用其所有权语义的智能指针**类型（重载了 `operator->` 或 `operator*` 的类型）的**参数**；
亦即

* 它是**可复制**的，但从**未被复制**/移动出来，或者它是**可移动**，但从未被移动出来
* 并且从未对其进行修改或者将其传递给会进行修改的其他函数。

### <a name="Rf-pure"></a>F.8: 优先采用纯函数

##### 理由

**纯函数更容易进行推导**，有时候也更易于优化（甚至并行化），有时候还可以进行存储。

##### 示例

```c++
template<class T>
auto square(T t) { return t * t; }
```

##### 强制实施

不可能进行强制实施。

### <a name="Rf-unused"></a>F.9: 未使用的形参应当没有名字

##### 理由

可读性。
抑制**未使用形参的警告**消息。

##### 示例

```c++
X* find(map<Blob>& m, const string& s, Hint);   // 这里曾经使用过一个提示
```

##### 注解

为解决这个问题，在 1980 年代早期就引入了**允许形参无名的规则**。

##### 强制实施

**对有名字的未使用形参进行标记**。

## <a name="SS-call"></a>F.call: 参数传递

存在各种**不同**的向函数**传递参数**和**返回值**的方式。

### <a name="Rf-conventional"></a>F.15: 优先采用简单的和传统的信息传递方式

##### 理由

使用"与众不同和精巧"的技巧会带来意外，其他程序员的理解减慢，并促进 BUG 的发生。
如果你确实想要比常规技巧更好的优化，请进行测量以确保它真的有所提升，并为其写下文档/注释，因为这种提升可能无法移植。

下面的表格总结了以下 F.16-21 的各个指导方针中的建议。

一般性参数传递：

![一般性参数传递表](./param-passing-normal.png "一般性参数传递")

高级参数传递：

![高级参数传递表](./param-passing-advanced.png "高级参数传递")

只有在进行论证必要之后再使用高级技巧，并将其必要性注明在代码注释中。

对于字符序列的传递，参见 [字符串](#SS-string)。

### <a name="Rf-in"></a>F.16: 对于"输入（in）"参数，把复制操作廉价的类型按值进行传递，把其他类型按 `const` 引用进行传递

##### 理由

既能让调用者了解函数不会修改其参数，也使得参数能够以右值初始化。

**何谓"复制操作廉价"依赖于机器的架构**，不过只有两三个机器字（Word）的类型（double，指针，引用等）一般最好按值传递。
**当可以廉价复制时，没什么比得过进行复制的简单性和安全性**，而且对于小型对象（最多两三个机器字）来说，**也比按引用传递更快**，因为它**不需要在函数中进行一次额外的间接访问**。  

##### 示例

```c++
void f1(const string& s);  // OK: 按 const 引用传递; 总是廉价的

void f2(string s);         // bad: 可能是昂贵的

void f3(int x);            // OK: 无可比拟

void f4(const int& x);     // bad: f4() 中的访问带来开销
```

（仅）对于**高级的运用**，如果你确实需要**为"只当作输入"的参数的按右值传递**进行优化的话：

* 如果函数需要**无条件地从参数进行移动**，那就按 `&&` 来接受参数。参见 [F.18](#Rf-consume)。
* 如果函数需要**保留参数的一个副本**，那就在**按 `const&` 接受参数**（对于左值）除外，
  添加一个**按 `&&` 传递参数（对于右值）的重载**，并在函数体中将之 `std::move` 到其目标之中。基本上，这个重载是"将被移动（will-move-from）"；参见 [F.18](#Rf-consume)。
* **在特殊情况中，比如有多个"输入+复制"的参数时，考虑采用完美转发**。参见 [F.19](#Rf-forward)。

##### 示例

```c++
int multiply(int, int); // 仅输入了 int，按值传递

// suffix 仅作输入，但并不如 int 那样廉价，因此按 const& 传递
string& concatenate(string&, const string& suffix);

void sink(unique_ptr<widget>);  // 仅作输入，但移动了这个 widget 的所有权
```

**避免**以下这类的"玄奥技巧"：

* **"为了效率"而按 `T&&` 来传递参数**。
  关于**按 `&&` 传递带来性能好处的大多数传言都是假的或者是脆弱的**（不过也请参考 [F.18](#Rf-consume) 和 [F.19](#Rf-forward)）。
* 从**赋值**或相似的操作中**返回 `const T&`**（参见 [F.47](#Rf-assignment-op)）。

##### 示例

假设 `Matrix` 带有移动操作（可能它将其元素都保存在一个 `std::vector` 中）：
```c++
    Matrix operator+(const Matrix& a, const Matrix& b)
    {
        Matrix res;
        // ... 用二者的和填充 res ...
        return res;
    }
    
    Matrix x = m1 + m2;  // 移动构造函数
    
    y = m3 + m3;         // 移动赋值
```
##### 注解

返回值优化无法处理赋值的情况，不过移动赋值却可以。

引用是被假定为指代某个有效对象的（语言规则）。
"空引用"（正规地说）是不存在的。
如果要**表示一个非强制的值，请使用指针**，`std::optional`，或者一个**用以代表"没有值"的特殊值**。

##### 强制实施

* 【简单】〔基础〕 当按**值传递**的参数的大小**大于** `2 * sizeof(void*)` 时给出警告。
  建议代之以 `const` 的引用。
* 【简单】〔基础〕 当**按 `const` 引用传递**的参数的大小**小于** `2 * sizeof(void*)` 时给出警告。建议代之以按值传递。
* 【简单】〔基础〕 当**按 `const` 引用传递的参数被 `move` 时**给出警告。

### <a name="Rf-inout"></a>F.17: 对于"输入/输出（in-out）"参数，按非 `const` 引用进行传递

##### 理由

让调用者明了这个**对象假定将会被改动**。

##### 示例

```c++
void update(Record& r);  // 假定 update 将会写入 r
```

##### 注解

`T&` 参数既可以向函数中传递信息，也可以传递出来。
**因此 `T&` 能够作为"输入/输出"参数。这点本身就可能是一种错误的来源**：

```c++
void f(string& s)
{
    s = "New York";  // 不明显的错误
}

void g()
{
    string buffer = ".................................";
    f(buffer);
    // ...
}
```

这里，`g()` 的作者提供了一个缓冲区让 `f()` 来填充，但 `f()` 仅仅替换掉了它（以多少比简单的字符复制高一些的成本）。
如果 `g()` 的作者对 `buffer` 的**大小作出了错误的假设**的话，就会发生糟糕的逻辑错误。

##### 强制实施

* 【中等】〔基础〕 对带有指向**非 `const` 的引用参数但又不进行写入**的函数给出**警告**。
* 【简单】〔基础〕 当按**引用传**递的非 `const` 参数被进行 **`move` 时给出引用**。

### <a name="Rf-consume"></a>F.18: 对于"将被移动（will-move-from）"参数，按 `X&&` 进行传递并对参数 `std::move`

##### 理由

这样做**很高效**，并且消除了调用点的 BUG：`X&&` 绑定到右值，而要传递左值的话则要求在调用点明确进行 `std::move`。

##### 示例

```c++
void sink(vector<int>&& v) {   // 无论参数所拥有的是什么，sink 都获得了其所有权
    // 通常这里可能有对 v 的 const 访问
    store_somewhere(std::move(v));
    // 通常这里不再会使用 v 了；它已经被移走
}
```

注意，`std::move(v)` 使得 `store_somewhere()` 可以把 `v` 遗留为被移走的状态。
[这可能很危险](#Rc-move-semantic)。


##### 例外

**只能移动并且移动廉价的唯一拥有者类型**，比如 `unique_ptr`，也可以按值传递，这样写起来更简单而且效果相同。按值传递确实产生了一次额外的（廉价）移动操作，但我们更加**优先于简单性和清晰性**。

例如：

```c++
template <class T>
void sink(std::unique_ptr<T> p) {
    // 使用 p ... 可能在之后的什么地方 std::move(p)
}   // p 被销毁
```

##### 强制实施

* 对于**所有 `X&&` 参数**（其中的 `X` 不是模板类型参数的名字），如果函数体中使用它时**没有用 `std::move`**，就将其标明。
* **标明对已经被移动过的对象的访问**。
* 不要有条件地从对象进行移动。

### <a name="Rf-forward"></a>F.19: 对于"转发（forward）"参数，按 `TP&&` 进行传递并只对参数 `std::forward`

##### 理由

如果一个对象要被传递给其他代码而并**不在本函数中直接使用**，我们就想让这个函数对于该参数的 `const` 性质和右值性质来说是中立的。

这种情况下，而且只有这种情况下，才应当让参数为 `TP&&`，其中 `TP` 为模板类型参数——它既*忽略*了也*保持*了 `const` 性质和右值性质。因而使用 `TP&&` 的任何代码都隐含地声称它自己并不关心变量的 `const` 性质和右值性质（因为这被忽略了），但它有意把值继续传递给其他确实关心 `const` 性质和右值性质的代码（因为这也是被保持的）。把 `TP&&` 用于参数类型上是安全的，因为从调用方传递来的任何临时对象都会在函数调用期间一直存活。基本上 `TP&&` 类型的参数应当总是在函数体中通过 `std::forward` 来继续传递。

##### 示例

```c++
template <class F, class... Args>
inline auto invoke(F f, Args&&... args) {
    return f(forward<Args>(args)...);//自己未使用，直接转发给别人了
}

??? calls ???
```

##### 强制实施

* 对于接受 `TP&&` 参数的函数（其中的 `TP` 不是模板类型参数的名字），如果函数对它做了任何别的事，而不是在每个静态路径中都正好进行一次 `std::forward`，就将函数进行标明。

### <a name="Rf-out"></a>F.20: 对于"输出（out）"值，采用返回值优先于输出参数

##### 理由

返回值是自我说明的，而 `&` 参数则既可能是输入/输出的也可能是仅输出的，并且倾向于被误用。

适用的情况也包括如标准容器这样的大型对象，它们为性能因素使用了隐式的移动操作，并且避免进行显式的内存管理。

**当有多个值要返回时，[使用元组](#Rf-out-multi)或者类似的多成员类型。**

##### 示例

```cpp
// OK: 返回指向具有 x 值的元素的指针
vector<const int*> find_all(const vector<int>&, int x);

// 不好: 把指向具有 x 值的元素的指针放入 out
void find_all(const vector<int>&, vector<const int*>& out, int x);
```

##### 注解

含有许多（每个都廉价移动的）元素的 `struct`，**聚合起来则可能是移动操作昂贵的**。

不建议返回 `const` 值。
这种老旧的建议已经过时了；它并不会带来什么价值，而且还会对移动语义造成影响。

```c++
const vector<int> fct();    // 不好: 这个 "const" 带来的麻烦超过其价值

vector<int> g(const vector<int>& vx)
{
    // ...
    fct() = vx;   // 被 "const" 所禁止
    // ...
    return fct(); // 昂贵的复制："const" 抑制掉了移动语义
}
```

**要求对返回值添加 `const` 的理由**是可以防止（非常少见的）对临时对象的意外访问。
而反对的理由则是**妨碍了（非常常见的）对移动语义的利用**。

##### 例外

* 对于非值类型，比如**继承层次中的类型来说**，**可以用 `unique_ptr` 或 `shared_ptr` 来返回对象**。
* 如果类型的移动操作昂贵（比如 `array<BigPOD>`），就考虑将其分配在自由存储中并返回一个句柄（比如 `unique_ptr`），或者传递一个指代用以填充的**非 `const` 目标对象的引用**（将其用作输出参数）。
* 对于内部循环中的**多次函数调用之间重用自带容量的对象**（比如 `std::string` 和 `std::vector`）：[将其按照输入/输出参数处理，并按引用传递](#Rf-out-multi)。

##### 示例

```c++
struct Package {      // 特殊情况: 移动操作昂贵的对象
    char header[16];
    char load[2024 - 16];
};

Package fill();       // 不好: 大型的返回值
void fill(Package&);  // OK

int val();            // OK
void val(int&);       // 不好: val 会不会读取参数？
```

##### 强制实施

* 对于指代非 `const` 的引用参数，如果其**被写入之前未进行过读取**，而且其类型能够廉价地返回，则标记它们；它们应当是"输入"的返回值。
* 标记 `const` 返回值。修正方法：**移除 `const` 使其变为返回非 `const` 值**。

### <a name="Rf-out-multi"></a>F.21: 要返回多个"输出"值，优先返回结构体或元组（tuple）

##### 理由

**返回值是自我说明为"仅输出"值的**。
注意，**C++ 是支持多返回值的，按约定使用的是 `tuple`（包括 `pair`）**，
并可以在**调用点使用 `tie` 以带来更多的便利**。
**优先使用具名的结构体**，使其返回值具有语义。不过，没有名字的 `tuple` 在泛型代码中则很有用。

##### 示例

```c++
// 不好: 在代码注释作用说明仅作输出的参数
int f(const string& input, /*output only*/ string& output_data)
{
    // ...
    output_data = something();
    return status;
}

// 好: 自我说明的
tuple<int, string> f(const string& input)
{
    // ...
    return make_tuple(status, something());
}
```

C++98 的标准库已经使用这种风格了，因为 `pair` 就像一种两个元素的 `tuple` 一样。
例如，给定一个 `set<string> my_set`，请考虑：

```c++
// C++98
result = my_set.insert("Hello");
if (result.second) do_something_with(result.first);    // 变通方案
```

在 C++11 中我们可以这样写，将结果直接放入现存的局部变量中：

```c++
Sometype iter;                                // 如果我们还未因为别的目的而使用
Someothertype success;                        // 这些变量，则进行默认初始化

tie(iter, success) = my_set.insert("Hello");   // 普通的返回值
if (success) do_something_with(iter);
```

而在 **C++17 中，我们可以使用"结构化绑定"对多个变量进行声明和初始化**：

```c++
if (auto [ iter, success ] = my_set.insert("Hello"); success) do_something_with(iter);
```

##### 例外

有时候需要把**对象传递**给函数让其操纵它的状态。
这种情况下，按**引用传递对象 [`T&`](#Rf-inout) 通常是恰当的技巧**。
显式传递一个输入/输出参数再让其作为返回值返回出来通常是没必要的。
例如：

```c++
istream& operator>>(istream& is, string& s);    // 与 std::operator>>() 很相似

for (string s; cin >> s; ) {
    // 对文本行做些事
}
```

这里，`s` 和 `cin` 都用作了输入/输出参数。
`cin` 按（非 `const`）引用来传递，以便可以操作其状态。
**`s` 的传递是为避免重复进行分配**。
通过重用 `s`（按引用传递），我们只需要在为扩展 `s` 的容量时才会分配新的内存。
这种技巧有时候被称为"调用方分配的输出参数"模式，它特别适合于
**诸如 `string` 和 `vector` 这样需要进行自由存储分配的类型**。

比较一下，如果所有的值都按返回值传递出来的话，得像如下这样做：

```c++
pair<istream&, string> get_string(istream& is);  // 不建议这样做
{
    string s;
    is >> s;
    return {is, s};
}

for (auto p = get_string(cin); p.first; ) {
    // 对 p.second 做些事
}
```

我们觉得这样明显不够简洁，而且性能明显更差。

当严格理解这条规则（F.21）时，这些例外并不真的算是例外，**因为它依赖于输入/输出参数**，
而不是规则中提到的单纯的输出参数。
不过我们倾向于进行明确而不是精巧的说明。

##### 注解

许多情况下，**返回某种用户定义的某个专门的类型**是有好处的。
例如：

```c++
struct Distance {
    int value;
    int unit = 1;   // 1 表示一米
};

Distance d1 = measure(obj1);        // 访问 d1.value 和 d1.unit
auto d2 = measure(obj2);            // 访问 d2.value 和 d2.unit
auto [value, unit] = measure(obj3); // 访问 value 和 unit；
                                    // 对于了解 measure() 的人来说有点多余
auto [x, y] = measure(obj4);        // 请勿如此；这很可能造成混乱
```

只有当返回的值表现的是**几个无关实体**而不是某个抽象的时候，**才应使用过于通用的 `pair` 和 `tuple`。**

作为另一个例子，应当使用像 `variant<T, error_code>` 这样的专门的类型，而不使用通用的 `tuple`。

##### 强制实施

* **输出参数应当被替换为返回值**。
  输出参数时由函数写入的，调用了非 `const` 成员函数的，或者将它作为非 `const` 参数继续传递的参数。

### <a name="Rf-ptr"></a>F.22: 用 `T*`，`owner<T*>` 或者智能指针来代表一个对象

##### 理由

可读性：这样能够**明确普通指针**的含义。
带来了显著的工具支持。

##### 注解

在传统的 C 和 C++ 代码中，普通的 `T*` 有各种互相没什么关联的用法，比如：

* 标识单个对象（本函数内**不会进行 delete**）
* 指向分配于自由存储之中的一个对象（**随后将会 delete**）
* **持有 `nullptr` 值**
* 标识一个 **C 风格字符串**（以零结尾的字符数组）
* **标识一个数组**，其长度被分开指明
* **标识数组中的一个位置**

这样就难于了解代码真正做了什么和打算做什么。
它也会使检查工作和工具支持复杂化。

##### 示例

```c++
void use(int* p, int n, char* s, int* q)
{
    p[n - 1] = 666; // 不好: 不知道 p 是不是指向了 n 个元素；
                    // 应当假定它并非如此，否则应当使用 span<int>
    cout << s;      // 不好: 不知道 s 指向的是不是以零结尾的字符数组；
                    // 应当假定它并非如此，否则应当使用 zstring
    delete q;       // 不好: 不知道 *q 是不是在自由存储中分配的；
                    // 否则应当使用 owner
}
```

更好的做法

```c++
void use2(span<int> p, zstring s, owner<int*> q)
{
    p[p.size() - 1] = 666; // OK, 会造成范围错误
    cout << s; // OK
    delete q;  // OK
}
```

##### 注解

**`owner<T*>` 表示所有权，`zstring` 表示 C 风格的字符串。**

**再者**: 应当假定从指向 `T` 的智能指针（比如 `unique_ptr<T>`）中获得的 `T*`是指向**单个元素**的。

**参见**: [支持程序库](#S-gsl)

**参见**: [请勿将数组作为单个指针来传递](#Ri-array)

##### 强制实施

* 【简单】〔边界〕 **对指针类型的表达式的算术操作**，若其结果为指针类型的值，就给出警告。

### <a name="Rf-nullptr"></a>F.23: 用 `not_null<T>` 来表明"空值（null）"不是有效的值

##### 理由

清晰性。以 `not_null<T>` 为参数的函数很明确地说明，应当由该函数的调用者来负责进行任何必须的 `nullptr` 检查。
相似地，以 `not_null<T>` 为返回值的函数很明确地说明，该函数的调用者无须检查 `nullptr`。

##### 示例

`not_null<T*>` 让读者（人类或机器）明了，在进行解引用前不需要检查 `nullptr`。
而且当进行调试时，可以对 `owner<T*>` 和 `not_null<T>` 进行植入来进行正确性检查。

考虑：

    int length(Record* p);

当调用 `length(p)` 时，我应该先检查 `p` 是否为 `nullptr` 吗？是不是应当由 `length()` 的实现来检查 `p` 是否为 `nullptr`？

```c++
// 确保 p != nullptr 是调用者的任务
int length(not_null<Record*> p);

// length() 的实现者必须假定可能出现 p == nullptr
int length(Record* p);
```

##### 注解

**假定 `not_null<T*>` 不可能是 `nullptr`；而 `T*` 则可能为 `nullptr`；**二者都可以在内存中表示为 `T*`（因此**不会带来运行时开销**）。

##### 注解

`not_null` 不仅对内建指针有效。它也能在 `unique_ptr`，`shared_ptr`，以及其他指针式的类型上使用。

##### 强制实施

* 【简单】 当函数中的一个**原始指针在未测试 `nullptr`（或等价形式）**之前就被解引用时，就给出警告。
* 【简单】 当函数中的一个原始指针有时候会在测试 `nullptr`（或等价形式）后进行解引用，而有时候不会时，就报错。
* 【简单】 当函数中的**一个 `not_null` 指针进行了 `nullptr` 测试时**，就给出警告。

### <a name="Rf-range"></a>F.24: 用 `span<T>` 或者 `span_p<T>` 来代表一个半开序列

##### 理由

非正式和**不明确的范围（range）是一种错误来源**。

##### 示例

```c++
X* find(span<X> r, const X& v);    // 在 r 中寻找 v

vector<X> vec;
// ...
auto p = find({vec.begin(), vec.end()}, X{});  // 在 vec 中寻找 X{}
```

##### 注解

范围（Range）在 C++ 代码中十分常见。典型情况下，它们都是隐含的，且非常难于保证它们能够被正确使用。
特别地，给定一对儿参数 `(p, n)` 来代表数组 `[p:p+n)`，
通常来说**不可能确定 `*p` 后面是不是真的存在 `n` 个元素**。
`span<T>` 和 `span_p<T>` 两个简单的辅助类，分别用于代表范围 `[p:q)`，以及一个以 `p` 开头并以使谓词为真的第一个元素结尾的范围。

##### 示例

`span` 代表元素的范围，我们应当如何操作范围的各个元素呢？

```c++
void f(span<int> s)
{
    // 范围的遍历（保证正确进行）
    for (int x : s) cout << x << '\n';

    // C 风格的遍历（可能带有检查）
    for (gsl::index i = 0; i < s.size(); ++i) cout << s[i] << '\n';

    // 随机访问（可能带有检查）
    s[7] = 9;

    // 截取指针（可能带有检查）
    std::sort(&s[0], &s[s.size() / 2]);
}
```

##### 注解

**`span<T>` 对象并不拥有其元素，而且很小，可以按值传递**。

把**一个 `span` 对象作为参数传递的效率**完全等同于**传递一对儿指针参数**或者传递一个指针和一个整数计数值。

**参见**: [支持程序库](#S-gsl)

##### 强制实施

【复杂】 当对指针参数的访问是以其他整型类型的参数为边界限定时，就给出警告并建议改用 `span`。

### <a name="Rf-zstring"></a>F.25: 用 `zstring` 或者 `not_null<zstring>` 来代表 C 风格的字符串

##### 理由

**C 风格的字符串非常普遍**。它们是按一种约定方式定义的：就是以零结尾的字符数组。
我们必须把 C 风格的字符串从指向**单个字符的指针**或者**指向字符数组的老式的指针**当中区分出来。

当**不需要零结尾时，请使用 'string_view'**。

##### 示例

考虑：

```c++
int length(const char* p);
```

当调用 `length(p)` 时，我应该先检查 `p` 是否为 `nullptr` 吗？是不是应当由 `length()` 的实现来检查 `p` 是否为 `nullptr`？

```c++
// length() 的实现者必须假定可能出现 p == nullptr
int length(zstring p);

// it is the caller's job to make sure p != nullptr
int length(not_null<zstring> p);
```

##### 注解

`zstring` 不含有所有权。

**参见**: [支持程序库](#S-gsl)

### <a name="Rf-unique_ptr"></a>F.26: 当需要指针时，用 `unique_ptr<T>` 来传递所有权

##### 理由

使用 `unique_ptr` 是**安全地传递指针的最廉价**的方式。

**参见**：[C.50](#Rc-factory)关于何时从一个工厂中返回 `shared_ptr`。

##### 示例

```c++
unique_ptr<Shape> get_shape(istream& is)  // 从输入流中装配一个形状
{
    auto kind = read_header(is); // 从输入中读取头部并识别下一个形状
    switch (kind) {
    case kCircle:
        return make_unique<Circle>(is);
    case kTriangle:
        return make_unique<Triangle>(is);
    // ...
    }
}
```

##### 注解

当要传递的对象属于某个类层次，且将要**通过接口（基类）来使用它时，你需要传递一个指针而不是对象**。

##### 强制实施

【简单】 **当函数返回了局部分配了的原始指针时就给出警告**。建议改为使用 `unique_ptr` 或 `shared_ptr`。

### <a name="Rf-shared_ptr"></a>F.27: 用 `shared_ptr<T>` 来共享所有权

##### 理由

使用 `std::shared_ptr` 是表示共享所有权的标准方式。其含义是，最后一个拥有者负责删除对象。

##### 示例

```c++
shared_ptr<const Image> im { read_image(somewhere) };

std::thread t0 {shade, args0, top_left, im};
std::thread t1 {shade, args1, top_right, im};
std::thread t2 {shade, args2, bottom_left, im};
std::thread t3 {shade, args3, bottom_right, im};

// 脱离各线程
// 最后执行完的线程会删除这个图像
```

##### 注解

如果同时不可能超过一个所有者的话，优先**采用 `unique_ptr` 而不是 `shared_ptr`。**
`shared_ptr` 的作用是共享所有权。

注意，过于**普遍的使用 `shared_ptr` 是有成本**的（`shared_ptr` 的引用计数上的原子性操作会产生可测量的总体花费）。

##### 替代方案

**让单个对象来拥有这个共享对象**（比如一个**有作用域的对象**），并当其所有使用方都完成工作后（最好隐含地）销毁它。

##### 强制实施

【无法强制实施】 这种模式过于复杂，无法可靠地进行检测。

### <a name="Rf-ptr-ref"></a>F.60: 当"没有参数"是有效的选项时，采用 `T*` 优先于 `T&`

##### 理由

指针（`T*`）可能为 `nullptr`，而引用（`T&`）则不能，不存在合法的"空引用"。
有时候用 `nullptr` 作为一种代表"没有对象"的方式是有用处的，但若是没有这种情况的话，使用引用的写法更简单，而且可能会产生更好的代码。

##### 示例

```c++
string zstring_to_string(zstring p) // zstring 就是 char*; 这是一个 C 风格的字符串
{
    if (!p) return string{};    // p 可能为 nullptr; 别忘了要检查
    return string{p};
}

void print(const vector<int>& r)
{
    // r 指代一个 vector<int>; 不需要检查
}
```

##### 注解

**构造出一个本质上是 `nullptr` 的引用是可能的，但不是合法的 C++ 代码**（比如，`T* p = nullptr; T& r = (T&)*p;`）。
这种错误非常罕见。

##### 注解

如果你更喜欢指针写法（`->` 以及 `*` vs. `.`）的话，**`not_null<T*>` 可以提供和 `T&` 相同的保证**。

##### 强制实施

* Flag ???

### <a name="Rf-return-ptr"></a>F.42: 返回 `T*` 来（仅仅）给出一个位置

##### 理由

指针就是用来干这个的。
**使用 `T*` 来传递所有权其实是一种误用**。

##### 示例

```c++
Node* find(Node* t, const string& s)  // 在 Node 组成的二叉树中寻找 s
{
    if (!t || t->name == s) return t;
    if ((auto p = find(t->left, s))) return p;
    if ((auto p = find(t->right, s))) return p;
    return nullptr;
}
```

`find` 所返回的指针如果不是 `nullptr` 的话，就指定了一个含有 `s` 的 `Node`。
重要的是，这里面并没有暗含着把所指向的对象的所有权传递给调用者。

##### 注解

迭代器、索引值和引用也可以用来传递位置。
[当不需要使用 `nullptr`](#Rf-ptr-ref)，或者[当不会改变被指代的对象](???)时，用引用通常比用指针更好。

##### 注解

不要返回指向某个不在调用方的作用域中的东西的指针；参见 [F.43](#Rf-dangle)。

**参见**: [有关如何避免悬挂指针的讨论](#???)

##### 强制实施

* 标记出施加在普通 `T*` 上的 `delete`，`std::free()` 等等。
只有所有者才能被删除。
* 标记出赋值给普通 `T*` 的 `new`，`malloc()` 等等。
只有所有者才应当负责进行删除。

### <a name="Rf-dangle"></a>F.43: 不要（直接或间接）返回指向局部对象的指针或引用

##### 理由

避免由于使用了这种悬挂指针而造成的程序崩溃和数据损坏。

##### 示例, 不好

从函数返回后，其中的局部对象就不再存在了：

    int* f()
    {
        int fx = 9;
        return &fx;  // 不好
    }
    
    void g(int* p)   // 貌似确实是无辜的
    {
        int gx;
        cout << "*p == " << *p << '\n';
        *p = 999;
        cout << "gx == " << gx << '\n';
    }
    
    void h()
    {
        int* p = f();
        int z = *p;  // 从已经丢弃的栈帧中读取（不好）
        g(p);        // 把指向已丢弃栈帧的指针传递给函数（不好）
    }

我在一种流行的实现上得到了以下输出：

    *p == 999
    gx == 999

我预期这样的结果是因为，对 `g()` 的调用重用了被 `f()` 的调用所丢弃的栈空间，因此 `*p` 所指代的空间应当会被 `gx` 所占据。

* 请想象一下当 `fx` 和 `gx` 类型不同时会发生什么。
* 请想象一下当 `fx` 或 `gx` 的类型带有不变式时会发生什么。
* 请想象一下当在更大的一组函数之间传递的不止是悬挂指针时会发生什么。
* 请想象一下一个攻击者能够利用悬挂指针干些什么。

幸运的是，大多数（全部？）的当代编译器都可以识别这种简单的情况并给出警告。

##### 注解

这同样适用于引用：

    int& f()
    {
        int x = 7;
        // ...
        return x;  // 不好: 返回指代即将被销毁的对象的引用
    }

##### 注解

这条仅适用于非 `static` 的局部变量。
所有的 `static` 变量都是（顾名思义）静态分配的，因此指向它们的指针不可能变为悬挂的。

##### 示例, 不好

并非所有的局部变量指针的泄漏都是那么明显的：

    int* glob;       // 全局变量的不好的方面太多了
    
    template<class T>
    void steal(T x)
    {
        glob = x();  // 不好
    }
    
    void f()
    {
        int i = 99;
        steal([&] { return &i; });
    }
    
    int main()
    {
        f();
        cout << *glob << '\n';
    }

我这次成功从 `f` 的调用所丢弃的位置上读到了数据。
存于 `glob` 中的指针可能在很晚才被使用，并可能以无法预测的方式造成各种麻烦。

##### 注解

局部变量的地址的"返回"或者泄漏方式，可能是返回语句，以 `T&` 输出参数，以所返回对象的成员，以所返回数组的元素，还有更多其他方式。

##### 注解

还可以构造出相似的从内部作用域"泄漏"到外部作用域的例子；
对这样的例子应当按照与从函数中泄漏指针的相同方式来处理。

这个问题的一个略有不同的变体是，把指针放入容器使其生存期超过其所指向的对象。

**参见**: 另一种获得悬挂指针的方式是[指针失效](#???)。
这种情况也可以用相似的技术来检测和避免。

##### 强制实施

* 编译器通常可以发现返回局部对象 引用，许多情况下也可以发现返回指向局部对象的指针。
* 静态分析可以发现许多常见的确定指针位置的使用模式（因而可以消除掉悬挂指针）

### <a name="Rf-return-ref"></a>F.44: 当不想进行复制，而"没有对象被返回"不是有效的选项时，返回 `T&`

##### 理由

语言规则保证 `T&` 会指代对象，因此不需要对其测试 `nullptr`。

**参见**: 所返回的引用诀不能蕴含所有权的传递：
[有关如何避免悬挂指针的讨论](#???)以及[有关所有权的讨论](#???)。

##### 示例

    class Car
    {
        array<wheel, 4> w;
        // ...
    public:
        wheel& get_wheel(int i) { Expects(i < w.size()); return w[i]; }
        // ...
    };
    
    void use()
    {
        Car c;
        wheel& w0 = c.get_wheel(0); // w0 与 c 的生存期相同
    }

##### 强制实施

对不存在可能产生 `nullptr` 的 `return` 表达式的函数进行标记。

### <a name="Rf-return-ref-ref"></a>F.45: 不要返回 `T&&`

##### 理由

它要求返回对已销毁的临时对象的引用。
`&&` 是吸引临时对象的符号。

##### 示例

返回的右值引用超出了返回的完整表达式结束的范围：

    auto&& x = max(0, 1);   // 到目前为止，没问题
    foo(x);                 // 未定义的行为

这种用法是频繁产生 bug 的根源，经常错误地报告为编译器错误。
函数的实现者应避免为用户设置此类陷阱。

[生存期安全性](#SS-lifetime)完全执行时，会捕捉到这个问题。


##### 示例

当临时的引用"向下"传递给被调用对象时，返回右值引用是正常的；
然后，临时对象保证比函数调用生命期更长（参见 [F.18](#Rf-consume) 和 [F.19](#Rf-forward)）。
但是，将这样的引用"向上"传递给更大的调用范围时，不好。
对于通过普通引用或完美传递方式传递参数，并希望返回值的通过函数，使用简单的 `auto` 而不是 `auto &&` 返回推导的类型。

假定 "F" 按值返回：

    template<class F>
    auto&& wrapper(F f)
    {
        log_call(typeid(f)); // 或者别的什么测量手段
        return f();          // 不好：返回一个临时对象的引用
    }

更好的方式：

    template<class F>
    auto wrapper(F f)
    {
        log_call(typeid(f)); // 或者别的什么测量手段
        return f();          // 好
    }


##### 例外

`std::move` 和 `std::forward` 确实会返回 `&&`，但它们只不过是强制转换 —— 只会按惯例在某些表达式上下文中使用，其中指代临时对象的引用只会在该临时对象呗销毁之前在同一个表达式中被传递。我们不知道还存在任何别的返回 `&&` 的好例子。

##### 强制实施

对除了 `std::move` 和 `std::forward` 之外的任何把 `&&` 作为返回类型的情况都进行标记。

### <a name="Rf-main"></a>F.46: `int` 是 `main()` 的返回类型

##### Reason

这是一条语言规则，但通常被"语言扩展"所违反，因此值得一提。
把 `main`（即程序中的那个全局的 `main`）声明为 `void` 会限制其可移植性。

##### 示例

        void main() { /* ... */ };  // 不好，不符合 C++
    
        int main()
        {
            std::cout << "This is the way to do it\n";
        }

##### 注解

我们提出这条规则，只是因为这种错误持续存在于大众之间。

##### 强制实施

* 编译器应当做到。
* 如果编译器做不到，就让工具把它标记出来。

### <a name="Rf-assignment-op"></a>F.47: 赋值运算符返回 `T&`

##### 理由

运算符重载的惯例（尤其是对于值类型来说），是让
`operator=(const T&)` 实施赋值之后返回（非 `const`）的
`*this`。这就确保了与标准库类型之间的一致性，并遵从了
"像 `int` 一样工作"的原则。

##### 注解

历史上层有过一些建议让赋值运算符返回 `const T&`。
这主要是为了避免 `(a = b) = c` 形式的代码 —— 这种代码其实并不常见到足以成为违反与标准类型之间一致性的理由。

##### 示例

    class Foo
    {
     public:
        ...
        Foo& operator=(const Foo& rhs) {
          // 复制各个成员。
          ...
          return *this;
        }
    };

##### 强制实施

应当通过工具对所有赋值运算符的返回类型（和返回值）进行检查
来强制实施。


### <a name="Rf-return-move-local"></a>F.48: 不要用 `return std::move(local)`

##### 理由

有了确保进行的副本消除之后，现在在返回语句中明确使用 `std::move` 几乎总是不良的实践。

##### 示例，不好

    S f()
    {
      S result;
      return std::move(result);
    }

##### 示例，好

    S f()
    {
      S result;
      return result;
    }

##### 强制实施

应当通过工具对返回语句进行检查来强制实施。


### <a name="Rf-capture-vs-overload"></a>F.50: 当函数不适用时（不能俘获局部变量，或者不能编写局部函数），就使用 Lambda

##### 理由

函数不能俘获局部变量且不能在局部作用域中进行定义；当想要这些能力时，如果可能就应当使用 lambda，不行的就用手写的函数对象。另一方面，lambda 和函数对象是不能重载的；如果想要重载，就优先使用函数（让 lambda 重载的变通方案相当繁复）。如果两种方式都不行的话，就优先写一个函数；应当只使用所需的最简工具。

##### 示例

    // 编写只会接受 int 或 string 的函数
    // -- 重载是很自然的
    void f(int);
    void f(const string&);
    
    // 编写需要俘获局部状态的函数对象，可以出现于
    // 语句或者表达式作用域中 -- lambda 更自然
    vector<work> v = lots_of_work();
    for (int tasknum = 0; tasknum < max; ++tasknum) {
        pool.run([=, &v]{
            /*
            ...
            ... 处理 v 的 1 / max, 即第 tasknum 个部分
            ...
            */
        });
    }
    pool.join();

##### 例外

泛型的 lambda 可以提供一种更精简的编写函数模板的方式，因此会比较有用，虽然普通的函数模板用稍多一点儿的语法可以做到同样的事情。这种优势在未来一旦所有的函数都获得了 Concept 参数的能力之后就可能会消失。

##### 强制实施

* 有名字的非泛型 lambda（比如 `auto x = [](int i){ /*...*/; };`），而其并未发生俘获并且出现于全局作用域，对它们给出警告。代之以编写常规的函数。

### <a name="Rf-default-args"></a>F.51: 如果需要作出选择，采用默认实参应当优先于进行重载

##### 理由

默认实参本就是为一个单一实现提供替代的接口的。
无法保证一组重载函数全部都实现相同的语义。
使用默认实参可以避免出现代码重复。

##### 注解

当变化来自相同类型的一组参数时，需要在默认实参和重载两种方案之间进行选择。
例如：

    void print(const string& s, format f = {});

相对的则是

    void print(const string& s);  // 使用默认的 format
    void print(const string& s, format f);

如果要为一组不同类型来实现语义上等价的操作，就不需要进行选择了。例如：

    void print(const char&);
    void print(int);
    void print(zstring);

##### 参见


[虚函数的默认实参](#Rf-virtual-default-arg}

##### 强制实施

* 如果某个重载集合中的各个重载具有一个共同的形参前缀（例如 `f(int)`，`f(int, const string&)`，`f(int, const string&, double)`），则为其给出警告。（注意：如果这条强制措施实践中产生太多消息，请对此进行复查。）

### <a name="Rf-reference-capture"></a>F.52: 对于局部使用的（也包括传递给算法的）lambda，优先采用按引用俘获

##### 理由

为了效率和正确性，当使用局部的 lambda 时，你基本上总是需要进行按引用俘获。这也包括编写或者调用并行算法的情形，因为它们在返回前会进行联结。

##### 讨论

效率方面的考虑是，大多数的类型都是按引用传递比按值传递更便宜。

正确性方面的考虑是，许多的调用都希望在调用点对原本的对象实施副作用（参见下面的示例）。而按值传递妨碍了这点。

##### 注解

不幸的是，并没有一种简单的方法，能够按 `const` 引用来捕获以获得其局部调用的效率，同时又妨碍其副作用。

##### 示例

此处，一个大型对象（网络消息）被传递给一个迭代算法，而它也许不够高效，或者能够正确复制这个消息（它可能是无法复制的）：

    std::for_each(begin(sockets), end(sockets), [&message](auto& socket)
    {
        socket.send(message);
    });

##### 示例

下面是一个简单的三阶段并行管线。每个 `stage` 对象封装了一个工作线程和一个队列，有一个用来把任务入队的 `process` 函数，且其析构函数会自动进行阻塞以在线程结束前等待队列变空。

    void send_packets(buffers& bufs)
    {
        stage encryptor([] (buffer& b){ encrypt(b); });
        stage compressor([&](buffer& b){ compress(b); encryptor.process(b); });
        stage decorator([&](buffer& b){ decorate(b); compressor.process(b); });
        for (auto& b : bufs) { decorator.process(b); }
    }  // 自动阻塞以等待管线完成

##### 强制实施

对于按引用捕获的 lambda，若其并非局部地用在函数作用域中，或者若其被按引用传递给某个函数，则对其进行标记。（注意：这条规则是一种近似，但确实对按指针传递进行标记，它们更可能被受调方所保存，通过某个参数来向某个堆位置进行写入，返回 lambda，等等。生存期方面的规则也会提供一般性的规则，以针对包括通过 lambda 脱离的指针和引用进行标记。）

### <a name="Rf-value-capture"></a>F.53: 对于非局部使用的（包括被返回的，在堆上存储的，或者传递给别的线程的）lambda，避免采用按引用俘获

##### 理由

指向局部对象的指针和引用不能超出它们的作用域而存活。按引用捕获的 lambda 恰是另外一种保存指向局部对象的引用的地方，因而当它们（或其副本）存活超出作用域的话，也不应该这样做。

##### 示例，不好

    int local = 42;
    
    // 需要局部对象的引用。
    // 注意，当程序离开作用域时，
    // 局部对象不再存在，因此
    // process() 的调用将带有未定义行为！
    thread_pool.queue_work([&]{ process(local); });

##### 示例，好

    int local = 42;
    // 需要局部对象的副本。
    // 由于为局部变量建立了副本，它将在
    // 函数调用的全部时间内可用。
    thread_pool.queue_work([=]{ process(local); });

##### 强制实施

* 【简单】 当捕获列表中包含指代局部声明的变量的引用时给出警告。
* 【复杂】 当捕获列表中包含指代局部声明的变量的引用，而 lambda 被传递给非 `const` 且非局部的上下文时，进行标记。

### <a name="Rf-this-capture"></a>F.54: 当俘获了 `this` 时，显式俘获所有的变量（不使用默认俘获）

##### 理由

这是容易混淆的。在成员函数里边写 `[=]` 貌似会按引用来俘获，但其实会按引用俘获数据成员，因为它实际上按值俘获了不可见的 `this` 指针。如果你确实要这样做的话，请把 `this` 写明。

##### 示例

    class My_class {
        int x = 0;
        // ...
    
        void f() {
            int i = 0;
            // ...
    
            auto lambda = [=]{ use(i, x); };   // 不好: "貌似"按复制/按值俘获
            // [&] 在当前的语言规则下的语义是一样的，也会复制 this 指针
            // [=,this] 和 [&,this] 也没好多少，并且也会导致混淆
    
            x = 42;
            lambda(); // 调用 use(0, 42);
            x = 43;
            lambda(); // 调用 use(0, 43);
    
            // ...
    
            auto lambda2 = [i, this]{ use(i, x); }; // ok, 最明确并且最不混淆
    
            // ...
        }
    };

##### 注解

这在标准化之中正在进行积极的讨论，而且很可能在未来版本的标准中通过增加一种新的俘获模式或者调整 `[=]` 的含义而得到结局。当前的话，还是应当明确为好。

##### 强制实施

* 对指定了默认俘获的 lambda 俘获列表并且还（无论显式还是通过默认俘获）俘获了 `this` 的情况进行标识。

### <a name="F-varargs"></a>F.55: 不要使用 `va_arg` 参数

##### 理由

从 `va_arg` 中读取时需要假定确实传递了正确类型的参数。
而向变参传递时则需要假定将会读取正确的类型。
这样是很脆弱的，因为其在语言中无法一般性地强制其安全，因而需要靠程序员的纪律来保证其正确。

##### 示例

    int sum(...) {
        // ...
        while (/*...*/)
            result += va_arg(list, int); // 不好，假定所传递的是 int
        // ...
    }
    
    sum(3, 2); // ok
    sum(3.14159, 2.71828); // 不好，未定义的行为
    
    template<class ...Args>
    auto sum(Args... args) { // 好，而且更灵活
        return (... + args); // 注意：C++17 的"折叠表达式"
    }
    
    sum(3, 2); // ok: 5
    sum(3.14159, 2.71828); // ok: ~5.85987

##### 替代方案

* 重载
* 变参模板
* `variant` 参数
* `initializer_list`（同质的）

##### 注解

有时候，对于并不涉及实际的参数传递的技巧来说，声明 `...` 形参有其作用，比如当声明"接受任何东西"的函数，以在重载集合中禁止"其他所有东西"，或在模板元程序中表达一种"全覆盖（catchall）"情况时。

##### 强制实施

* 为 `va_list`，`va_start`，或 `va_arg` 的使用给出诊断。
* 如果 vararg 参数的函数并未提供重载以为该参数位置指定更加特定的类型，则当其传递参数时给出诊断。修正：使用别的函数，或标明 `[[suppress(types)]]`。

# <a name="S-class"></a>C: 类和类层次

类是一种自定义类型，程序员可以定义它的表示，操作和接口。
类层次用于把相关的类组织到层次化的结构当中。

类的规则概览：

* [C.1: 把相关的数据组织到结构中（`struct` 或 `class`）](#Rc-org)
* [C.2: 当类具有不变式时使用 `class`；当数据成员可以独立进行变动时使用 `struct`](#Rc-struct)
* [C.3: 用类来表示接口和实现之间的区别](#Rc-interface)
* [C.4: 仅当函数直接访问类的内部表示时才让函数作为其成员](#Rc-member)
* [C.5: 把辅助函数放在其所支持的类相同的命名空间之中](#Rc-helper)
* [C.7: 不要在同一个语句中同时定义类或枚举并声明该类型的变量](#Rc-standalone)
* [C.8: 当有任何非公开成员时使用 `class` 而不是 `struct`](#Rc-class)
* [C.9: 让成员的暴露最小化](#Rc-private)

子章节：

* [C.concrete: 具体类型](#SS-concrete)
* [C.ctor: 构造函数，赋值和析构函数](#S-ctor)
* [C.con: 容器和其他资源包装](#SS-containers)
* [C.lambdas: 函数对象和 lambda](#SS-lambdas)
* [C.hier: 类层次（OOP）](#SS-hier)
* [C.over: 重载和运算符重载](#SS-overload)
* [C.union: 联合体](#SS-union)

### <a name="Rc-org"></a>C.1: 把相关的数据组织到结构中（`struct` 或 `class`）

##### 理由

易理解性。
如果数据之间（以基本的原因而）相关，应当在代码中体现这点。

##### 示例

    void draw(int x, int y, int x2, int y2);  // 不好: 不必要的隐含式的关系
    void draw(Point from, Point to);          // 好多了

##### 注解

没有虚函数的简单的类是不会带来空间或时间开销的。

##### 注解

从语言的角度看，`class` 和 `struct` 的差别只有其成员的默认可见性不同。

##### 强制实施

也许不可能做到。也许对总是一起使用的数据项目进行启发式查找是一种可能方式。

### <a name="Rc-struct"></a>C.2: 当类具有不变式时使用 `class`；当数据成员可以独立进行变动时使用 `struct`

##### 理由

可读性。
易理解性。
`class` 的使用会提醒程序员需要考虑不变式。
这是一种很有用的惯例。

##### 注解

不变式是对象的成员之间的一种逻辑条件，必须由构造函数建立，并由公开成员函数假定成员。
不变式一旦建立（通常是由构造函数），就可以对对象的各个成员函数进行调用了。
不变式既可以非正式地说明（比如在代码注释中），也可以正式地用 `Expects` 说明。

如果数据成员都可以互相独立地进行改变，则不可能存在不变式。

##### 示例

    struct Pair {  // 成员可以独立地变动
        string name;
        int volume;
    };

但是：

    class Date {
    public:
        // 验证 {yy, mm, dd} 是有效的日期并进行初始化
        Date(int yy, Month mm, char dd);
        // ...
    private:
        int y;
        Month m;
        char d;    // day
    };

##### 注解

如果一个类中有任何的 `private` 数据的话，其使用者就不可能不通过构造函数而完全初始化一个对象。
因此，类的定义者必然提供构造函数且必须明确其含义。
这就相当于表示该定义者需要定义一种不变式。

**参见**：

* [把带有私有数据的类定义为 `class`](#Rc-class)
* [优先将接口部分放在类的开头](#Rl-order)
* [使成员的暴露最小化](#Rc-private)
* [避免 `protected` 数据](#Rh-protected)

##### 强制实施

查找所有数据都私有的 `struct` 和带有公开成员的 `class`。

### <a name="Rc-interface"></a>C.3: 用类来表示接口和实现之间的区别

##### 理由

接口和实现之间的明确区别能够提升可读性并简化维护工作。

##### 示例

    class Date {
    public:
        Date();
        // 验证 {yy, mm, dd} 是有效的日期并进行初始化
        Date(int yy, Month mm, char dd);
    
        int day() const;
        Month month() const;
        // ...
    private:
        // ... 一些内部表示 ...
    };

比如说，我们现在可以改变 `Date` 的表示而不对其使用者造成影响（虽然很可能需要重新编译）。

##### 注解

使用这样的类来表示接口和实现之间的区别当然不是唯一可能的方式。
比如说，我们也可以使用命名空间中的一组自由函数，一个抽象基类，或者一个带有概念的模板函数来表示一个接口。
最重要的一点，在于明确地把接口和其实现"细节"区分开来。
理想地，并且典型地，接口要比其实现稳定得多。

##### 强制实施

???

### <a name="Rc-member"></a>C.4: 仅当函数直接访问类的内部表示时才让函数作为其成员

##### 理由

比成员函数更少的耦合，减少可能由于改动对象状态而造成问题的函数，减少每当改变内部表示时需要进行修改的函数数量。

##### 示例

    class Date {
        // ... 相对较小的接口 ...
    };
    
    // 辅助函数:
    Date next_weekday(Date);
    bool operator==(Date, Date);

这些"辅助函数"并不需要直接访问 `Date` 的内部表示。

##### 注解

当 C++ 带来[统一函数调用](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0251r0.pdf)之后，这条规则会更有效。

##### 例外

语言规定 `virtual` 函数为成员函数，而并非所有的 `virtual` 函数都会直接访问数据。
特别是，抽象类的成员很少这样做。

注意 [multi methods](https://parasol.tamu.edu/~yuriys/papers/OMM10.pdf)。

##### 例外

语言规定运算符 `=`，`()`，`[]` 和 `->` 是成员函数。

##### 示例

一个重载集合中的一些成员可能不会直接访问 `private` 数据：

    class Foobar {
    public:
        void foo(long x)    { /* 操作 private 数据 */ }
        void foo(double x) { foo(std::lround(x)); }
        // ...
    private:
        // ...
    };

##### 例外

类似地，一组函数可能被设计为进行链式调用：

    x.scale(0.5).rotate(45).set_color(Color::red);

典型情况下，这些函数中的一些而并非全部会访问 `private` 数据。

##### 强制实施

* 寻找并不直接访问数据成员的非 `virtual` 成员函数。
麻烦的是由许多并不需要直接访问数据成员的函数也会这么做。
* 忽略 `virtual` 函数。
* 忽略至少包含一个访问了 `private` 成员的函数的重载集合中的函数。
* 忽略返回 `this` 的函数。

### <a name="Rc-helper"></a>C.5: 把辅助函数放在其所支持的类相同的命名空间之中

##### 理由

辅助函数是（由类的作者提供的）并不需要直接访问类的内部表示的函数，它们也被当作是类的可用接口的一部分。
把它们和类放在相同的命名空间中，使它们与类的关系更明显，并允许通过基于参数的查找机制找到它们。

##### 示例

    namespace Chrono { // 我们在这里放置与时间有关的服务
    
        class Time { /* ... */ };
        class Date { /* ... */ };
    
        // 辅助函数:
        bool operator==(Date, Date);
        Date next_weekday(Date);
        // ...
    }

##### 注解

这点对于[重载运算符](#Ro-namespace)来说尤其重要。

##### 强制实施

* 对接受某一个命名空间中的参数类型的全局函数进行标记。

### <a name="Rc-standalone"></a>C.7: 不要在同一个语句中同时定义类或枚举并声明该类型的变量

##### 理由

在同一个声明式中混合类型的定义和另一个实体的定义会导致混淆，而且不是必要的。

##### 示例，不好

    struct Data { /*...*/ } data{ /*...*/ };

##### 示例，好

    struct Data { /*...*/ };
    Data data{ /*...*/ };

##### 强制实施

* 如果类或者枚举的定义式的 `}` 后面没有跟着 `;` 就标记出来。它缺少了 `;`。

### <a name="Rc-class"></a>C.8: 当有任何非公开成员时使用 `class` 而不是 `struct`

##### 理由

可读性。
表明有些东西被隐藏或者进行了抽象。
这是一种有用的惯例。

##### 示例，不好

    struct Date {
        int d, m;
    
        Date(int i, Month m);
        // ... 许多函数 ...
    private:
        int y;  // year
    };

这段代码在 C++ 语言规则方面没有任何问题，
但从设计角度看则几乎全是错误。
私有数据和公开数据相比藏得太远了。
数据在类的声明式中被分到了不同的部分中。
不同部分的数据具有不同的访问性。
所有这些都减弱了可读性，并使维护变得更复杂。

##### 注解

优先将接口部分放在类的开头，[参见 NL.16](#Rl-order)。

##### 强制实施

对于声明为 `struct` 的类，当其带有 `private` 或 `protected` 成员时就进行标记。

### <a name="Rc-private"></a>C.9: 让成员的暴露最小化

##### 理由

封装。
信息隐藏。
使发生意外访问的机会最小化。
这会简化维护工作。

##### 示例

    template<typename T, typename U>
    struct pair {
        T a;
        U b;
        // ...
    };

无论我们在 `//` 部分中干什么，`pair` 的任意用户都可以任意地并且不相关地改动其 `a` 和 `b`。
在大型代码库中，我们无法轻易找出哪段代码对 `pair` 的成员都做了什么。
这可能正是我们想要的，但如果想要在成员之间强加某种关系，就需要使它们为 `private`，
并通过构造函数和成员函数来强加这种关系（不变式）。
例如：

    class Distance {
    public:
        // ...
        double meters() const { return magnitude*unit; }
        void set_unit(double u)
        {
                // ... 检查 u 是 10 的倍数 ...
                // ... 适当地改变幅度 ...
                unit = u;
        }
        // ...
    private:
        double magnitude;
        double unit;    // 1 为米，1000 为千米，0.001 为毫米，等等
    };

##### 注解

如果无法轻易确定一组变量的直接用户的集合，那么这个集合的类型或用法也无法被（轻易）改变或改进。
对于 `public` 和 `protected` 数据来说这是常见的情况。

##### 示例

一个类可以向其用户提供两个接口。
一个针对其派生类（`protected`），而另一个针对一般用户（`public`）。
例如，可能允许派生类跳过某种运行时检查，因为其已经确保了正确性：

    class Foo {
    public:
        int bar(int x) { check(x); return do_bar(x); }
        // ...
    protected:
        int do_bar(int x); // 在数据上做些操作
        // ...
    private:
        // ... 数据 ...
    };
    
    class Dir : public Foo {
        //...
        int mem(int x, int y)
        {
            /* ... 做一些事 ... */
            return do_bar(x + y); // OK：派生类可以略过检查
        }
    };
    
    void user(Foo& x)
    {
        int r1 = x.bar(1);      // OK，有检查
        int r2 = x.do_bar(2);   // 错误：可能略过检查
        // ...
    }

##### 注解

[`protected` 数据不是好主意](#Rh-protected)。

##### 注解

优先让 `public` 成员在前，`protected` 成员其次，`private` 成员在后[参见](#Rl-order)。

##### 强制实施

* [标记 `protected` 数据](#Rh-protected)。
* 标记混合的 `public` 和 `private` 数据。

## <a name="SS-concrete"></a>C.concrete: 具体类型

类的理想情况，是成为一个正规类型。
其大致上的意思就是"表现为像 `int` 一样"。具体类型是一种最简单的类。
可以对正规类型的值进行复制，复制的结果是一个与原始对象具有相同的值的独立对象。
当一个具体类型同时具有 `=` 和 `==` 时，`a = b` 的结果应当导致 `a == b` 为 `true`。
也可以定义出没有赋值和相等运算符的具体类，但它们（应当）是罕见情况。
C++ 的内建类型都是正规的，标准库中的类，如 `string`，`vector` 和 `map` 等也同样如此。
具体类型也常被称为值类型，以便与继承层次中的类型之间进行区分。

具体类型的规则概览：

* [C.10: 优先使用具体类型而不是类继承层次](#Rc-concrete)
* [C.11: 使具体类型正规化](#Rc-regular)

### <a name="Rc-concrete"></a>C.10: 优先使用具体类型而不是类继承层次

##### 理由

具体类型在本质上就比继承层次更简单：
它们更易于设计，更易于实现，更易于使用，更易于进行推理，更小，也更快。
使用继承层次是需要一些理由（用例）来支持的。

##### 示例

    class Point1 {
        int x, y;
        // ... 一些操作 ...
        // ... 没有虚函数 ...
    };
    
    class Point2 {
        int x, y;
        // ... 一些操作，其中有些是虚的 ...
        virtual ~Point2();
    };
    
    void use()
    {
        Point1 p11 {1, 2};   // 在栈上创建一个对象
        Point1 p12 {p11};    // 一个副本
    
        auto p21 = make_unique<Point2>(1, 2);   // 在自由存储中创建一个对象
        auto p22 = p21->clone();                // 创建一个副本
        // ...
    }

当一个类属于某个继承层次时，我们（即使在小例子中不需要，在真实代码中也）必然要通过指针或者引用来操作它的对象。
这意味着更多的内存开销，更多的分配和回收操作，以及更多的用于实施间接操作所带来的运行时开销。

##### 注解

具体类型可以在栈上分配，也可以成为其他类的成员。

##### 注解

对于运行时多态接口来说，使用间接是一项基本要求。
而分配/回收操作的开销则不是（它们只是最常见的情况而已）。
我们可以使用基类来作为有作用域的派生类对象的接口。
当禁止使用动态分配时（比如硬实时）就可以这样做，为某些种类的插件提供一种稳定的接口。


##### 强制实施

???

### <a name="Rc-regular"></a>C.11: 使具体类型正规化

##### 理由

正规类型比不正规的类型更易于理解和进行推导（不正规性会导致理解和使用上花费更多的精力）。

##### 示例

    struct Bundle {
        string name;
        vector<Record> vr;
    };
    
    bool operator==(const Bundle& a, const Bundle& b)
    {
        return a.name == b.name && a.vr == b.vr;
    }
    
    Bundle b1 { "my bundle", {r1, r2, r3}};
    Bundle b2 = b1;
    if (!(b1 == b2)) error("impossible!");
    b2.name = "the other bundle";
    if (b1 == b2) error("No!");

特别是，当具体类型带有赋值操作时，也应当为之提供相等运算符，以使得 `a = b` 蕴含 `a == b`。

##### 注解

无法进行克隆的资源包装类（例如，包含一个 `mutex` 的 `scoped_lock`），类似于大多数情况都进行栈分配的具体类型。
不过，这种类型的对象通常都无法进行复制（但它们一般都可以被移动），
因此它们不是 `regular`；但它们可以是 `semiregular`。
这样的类型通常都被称为"仅可移动类型"。

##### 强制实施

???

## <a name="S-ctor"></a>C.ctor: 构造函数，赋值，和析构函数

这些函数控制对象的生存期：创建，复制，移动，以及销毁。
定义构造函数是为了确保以及简化类的初始化过程。

以下被称为*默认操作*：

* 默认构造函数: `X()`
* 复制构造函数: `X(const X&)`
* 复制赋值: `operator=(const X&)`
* 移动构造函数: `X(X&&)`
* 移动赋值: `operator=(X&&)`
* 析构函数: `~X()`

缺省情况下，编译器会为这些操作中被使用的进行定义，但这些默认定义可以被抑制掉。

默认操作是一组互相关联的操作，它们共同实现了对象的生存期语义。
缺省情况下，C++ 按照值类型的方式来对待各个类，但并非所有的类型都与值类型相符。

默认操作的规则集合：

* [C.20: 只要可能，请避免定义任何的默认操作](#Rc-zero)
* [C.21: 如果对任何默认操作提供了定义或者 `=delete`，请为所有默认操作都提供定义或者 `=delete`](#Rc-five)
* [C.22: 使默认操作之间保持一致](#Rc-matched)

析构函数的规则：

* [C.30: 如果一个类需要在对象销毁时执行明确的操作，请为其定义析构函数](#Rc-dtor)
* [C.31: 类所获取的所有资源，必须都在类的析构函数中进行释放](#Rc-dtor-release)
* [C.32: 如果类中带有原始指针（`T*`）或者引用（`T&`），请考虑它是否是所有者](#Rc-dtor-ptr)
* [C.33: 如果类中带有所有权的指针成员，请定义析构函数或使之为 `=delete`](#Rc-dtor-ptr2)
* [C.35: 基类的析构函数应当要么是 public 和 virtual，要么是 protected 且非 virtual](#Rc-dtor-virtual)
* [C.36: 析构函数不能失败](#Rc-dtor-fail)
* [C.37: 使析构函数 `noexcept`](#Rc-dtor-noexcept)

构造函数的规则：

* [C.40: 如果类具有不变式，请为其定义构造函数](#Rc-ctor)
* [C.41: 构造函数应当创建经过完整初始化的对象](#Rc-complete)
* [C.42: 当构造函数无法构造有效对象时，应当抛出异常](#Rc-throw)
* [C.43: 保证可复制（值类型）类带有默认构造函数](#Rc-default0)
* [C.44: 尽量让默认构造函数简单且不抛出异常](#Rc-default00)
* [C.45: 不要定义仅对数据成员进行初始化的默认构造函数；应当使用成员初始化式](#Rc-default)
* [C.46: 默认情况下，把单参数的构造函数声明为 `explicit`](#Rc-explicit)
* [C.47: 按成员声明的顺序对成员变量进行定义和初始化](#Rc-order)
* [C.48: 对于常量初始化式来说，优先采用类中的初始化式而不是构造函数中的成员初始化式](#Rc-in-class-initializer)
* [C.49: 优先进行初始化而不是在构造函数中赋值](#Rc-initialize)
* [C.50: 当初始化过程中需要体现"虚函数行为"时，请使用工厂函数](#Rc-factory)
* [C.51: 用委派构造函数来表示类中所有构造函数的共同行为](#Rc-delegating)
* [C.52: 使用继承构造函数来把构造函数引入到无须进行其他的明确初始化操作的派生类之中](#Rc-inheriting)

复制和移动的规则：

* [C.60: 使复制赋值非 `virtual`，接受 `const&` 的参数，并返回非 `const` 的引用](#Rc-copy-assignment)
* [C.61: 复制操作应当进行复制](#Rc-copy-semantic)
* [C.62: 使复制赋值可以安全进行自赋值](#Rc-copy-self)
* [C.63: 使移动赋值非 `virtual`，接受 `&&` 的参数，并返回非 `const` 的引用](#Rc-move-assignment)
* [C.64: 移动操作应当进行移动，并使原对象处于有效状态](#Rc-move-semantic)
* [C.65: 使移动赋值可以安全进行自赋值](#Rc-move-self)
* [C.66: 使移动操作 `noexcept`](#Rc-move-noexcept)
* [C.67: 多态类应当抑制复制操作](#Rc-copy-virtual)

其他的默认操作规则：

* [C.80: 当需要明确使用缺省语义时，使用 `=default`](#Rc-eqdefault)
* [C.81: 当需要关闭缺省行为（且不需要替代的行为）时，使用 `=delete`](#Rc-delete)
* [C.82: 不要在构造函数和析构函数中调用虚函数](#Rc-ctor-virtual)
* [C.83: 考虑为值类型提供 `noexcept` 的 `swap` 函数](#Rc-swap)
* [C.84: `swap` 不应当失败](#Rc-swap-fail)
* [C.85: 使 `swap` 函数 `noexcept`](#Rc-swap-noexcept)
* [C.86: 使 `==` 对操作数的类型对称，并使之 `noexcept`](#Rc-eq)
* [C.87: 请当心基类的 `==`](#Rc-eq-base)
* [C.89: 使 `hash` 函数 `noexcept`](#Rc-hash)
* [C.90: 依靠构造函数和赋值运算符，不要依靠 `memset` 和 `memcpy`](#Rc-memset)

## <a name="SS-defop"></a>C.defop: 默认操作

缺省情况下，语言会提供具有预置语义的默认操作。
不过，程序员可以关闭或者替换掉这些缺省实现。

### <a name="Rc-zero"></a>C.20: 只要可能，请避免定义任何的默认操作

##### 理由

这样最简单，而且能提供最清晰的语义。

##### 示例

    struct Named_map {
    public:
        // ... 并未声明任何默认操作 ...
    private:
        string name;
        map<int, int> rep;
    };
    
    Named_map nm;        // 默认构造
    Named_map nm2 {nm};  // 复制构造

由于 `std::map` 和 `string` 都带有全部的特殊函数，这里并不需要做别的事情。

##### 注解

这被称为"零之准则（The rule of zero）"。

##### 强制实施

【无法强制实施】 虽然无法强制实施，但一个优秀的静态分析器可以检查出一些模式，指出可使之符合本条规则的改进可能性。
例如，一个带有（指针,大小）成员对，同时在析构函数中 `delete` 这个指针的类也许可以被转换为使用一个 `vector`。

### <a name="Rc-five"></a>C.21: 如果对任何默认操作提供了定义或者 `=delete`，请为所有默认操作都提供定义或者 `=delete`

##### 理由

*特殊成员函数*包括默认构造函数、复制构造函数，
复制赋值运算符，移动构造函数，移动赋值运算符，以及
析构函数。

特殊函数的语义互相之间是紧密相关的，一旦需要声明其中一个，麻烦的是其他的也需要予以考虑。

声明除了默认构造函数之外的任何特殊成员函数，
即便是声明为 `=default` 或 `=delete`，也将会抑制掉
移动构造函数和移动赋值运算符的隐式声明。
而声明移动构造函数或移动赋值运算符，
即便是声明为 `=default` 或 `=delete`，也将会导致隐式生成的复制构造函数
或隐式生成的复制赋值运算符被定义为弃置的。
因此，只要声明了任何一个特殊函数，就应当将
其他全部都予以声明，以避免出现预期外的效果，比如将所有潜在的移动
都变成了更昂贵的复制操作，或者使类变为只能移动的。

##### 示例，不好

    struct M2 {   // 不好: 不完整的默认操作集合
    public:
        // ...
        // ... 没有复制和移动操作 ...
        ~M2() { delete[] rep; }
    private:
        pair<int, int>* rep;  // pair 的以零终止的集合
    };
    
    void use()
    {
        M2 x;
        M2 y;
        // ...
        x = y;   // 缺省的赋值
        // ...
    }

既然对于析构函数需要"特殊关照"（这里是要进行回收操作），复制和移动赋值（它们都隐含地销毁对象）仍保持正确性的可能是很低的（此处会导致双重删除问题）。

##### 注解

这被称为"五之准则（The rule of five）"或"六之准则（The rule of six）"，区别是你是否把默认构造函数算入。

##### 注解

如果想保持默认操作的缺省实现（当定义了别的默认操作时），请写下 `=default` 以表明对这个函数是特意这样做的。
如果不想要一个默认操作，可以用 `=delete` 来抑制它。

##### 示例，好

如果要声明析构函数仅是为了使其为 `virtual` 的话，
可将其定义为预置的。为避免抑制隐式的移动操作，
它们也都要进行声明，而且为了避免类成为只能移动
（而无法复制）的，其复制操作也都需要进行声明：

    class AbstractBase {
    public:
      virtual ~AbstractBase() = default;
      AbstractBase(const AbstractBase&) = default;
      AbstractBase& operator=(const AbstractBase&) = default;
      AbstractBase(AbstractBase&&) = default;
      AbstractBase& operator=(AbstractBase&&) = default;
    };

另外，为避免发生如 [C.67](#Rc-copy-virtual) 所说的切片，
其复制和移动操作可以都被弃置：

    class ClonableBase {
    public:
      virtual unique_ptr<ClonableBase> clone() const;
      virtual ~ClonableBase() = default;
      ClonableBase(const ClonableBase&) = delete;
      ClonableBase& operator=(const ClonableBase&) = delete;
      ClonableBase(ClonableBase&&) = delete;
      ClonableBase& operator=(ClonableBase&&) = delete;
    };

这里仅定义移动操作或者进定义复制操作也可以具有
相同效果，但明确说明每个特殊成员的意图，
可使其对读者更加易于理解。

##### 注解

编译期会很大程度上强制实施这条规则，并在理想情况下会对任何违反都给出警告。

##### 注解

在带有析构函数的类中，依靠隐式生成的复制操作的做法已经被摒弃。

##### 注解

写这六个特殊成员函数可能容易出错。
注意它们的参数类型：

    class X {
    public:
        // ...
        virtual ~X() = default;            // 析构函数 (如果 X 是基类，用 virtual)
        X(const X&) = default;             // 复制构造函数
        X& operator=(const X&) = default;  // 复制赋值
        X(X&&) = default;                  // 移动构造函数
        X& operator=(X&&) = default;       // 移动赋值
    };

一个小错误（例如拼写错误，遗漏 `const`，使用 `&` 而不是 '&&`，或遗漏一个特殊功能）可能导致错误或警告。
为避免单调乏味和出错的可能性，请尝试遵循[零规则]（＃Rc-zero）。

##### 强制实施

【简单】 类中应当要么为每个特殊函数都提供一个声明（即便是 `=delete`），要么都不这样做。

### <a name="Rc-matched"></a>C.22: 使默认操作之间保持一致

##### 理由

默认操作是一个概念上向配合的集合。它们的语义是相互关联的。
如果复制/移动构造和复制/移动赋值所做的是逻辑上不同的事情的话，这会让使用者感觉诡异。如果构造函数和析构函数并不提供一种对资源管理的统一视角的话，也会让使用者感觉诡异。如果复制和移动操作并不体现出构造函数和析构函数的工作方式的话，同样会让使用者感觉诡异。

##### 示例，不好

    class Silly {   // 不好: 复制操作不一致
        class Impl {
            // ...
        };
        shared_ptr<Impl> p;
    public:
        Silly(const Silly& a) : p{a.p} { *p = *a.p; }   // 深复制
        Silly& operator=(const Silly& a) { p = a.p; }   // 浅复制
        // ...
    };

这些操作在复制语义上并不统一。这将会导致混乱和出现 BUG。

##### 强制实施

* 【复杂】 复制/移动构造函数和对应的复制/移动赋值运算符，应当在相同的解引用层次上向相同的成员变量进行写入。
* 【复杂】 在复制/移动构造函数中被写入的任何成员变量，在其他构造函数中也都应当进行初始化。
* 【复杂】 如果复制/移动构造函数对某个成员变量进行了深复制，就应当在析构函数中对这个成员变量进行修改。
* 【复杂】 如果析构函数修改了某个成员变量，在任何复制/移动构造函数或赋值运算符中就都应当对该成员变量进行写入。

## <a name="SS-dtor"></a>C.dtor: 析构函数

"这个类需要析构函数吗？"是一个出人意料强有力的设计问题。
对于大多数类来说，答案是"不需要"，要么是因为类中并没有保持任何资源，要么是因为销毁过程已经被[零之准则](#Rc-zero)处理掉了；
就是说，它的成员在销毁之中可以自己照顾自己。
当答案为"需要"时，类的大部分设计应当遵循下列规则（参见[五之准则](#Rc-five)）。

### <a name="Rc-dtor"></a>C.30: 如果一个类需要在对象销毁时执行明确的操作，请为其定义析构函数

##### 理由

析构函数是在对象的生存期结束时被隐式执行的。
如果预置的析构函数足堪使用的话，就应当用它。
只有当类需要执行的代码不在其成员的析构函数中时，才需要定义非预置的析构函数。

##### 示例

    template<typename A>
    struct final_action {   // 略有简化
        A act;
        final_action(A a) :act{a} {}
        ~final_action() { act(); }
    };
    
    template<typename A>
    final_action<A> finally(A act)   // 推断出动作的类型
    {
        return final_action<A>{act};
    }
    
    void test()
    {
        auto act = finally([]{ cout << "Exit test\n"; });  // 设置退出动作
        // ...
        if (something) return;   // 动作在这里得到执行
        // ...
    } // 动作在这里得到执行

`final_action` 的全部目的就是为了在其销毁时执行一段代码（通常是一个 lambda）。

##### 注解

需要自定义析构函数的类大致上有两种：

* 类中具有某个资源，而它并未表示成一个具有析构函数的类，比如 `vector` 或事物类。
* 类的目的主要用于在销毁时执行某个动作，比如一个追踪器，或者 `final_action`。

##### 示例，不好

    class Foo {   // 不好; 使用预置的析构函数
    public:
        // ...
        ~Foo() { s = ""; i = 0; vi.clear(); }  // 清理
    private:
        string s;
        int i;
        vector<int> vi;
    };

预置的析构函数会做得更好，更高效，而且不会出错。

##### 注解

当需要预置的析构函数，但其生成被抑制（比如由于定义了移动构造函数）时，可以使用 `=default`。

##### 强制实施

查找疑似"隐式的资源"，比如指针和引用等。查找带有析构函数的类，即便其所有数据成员都带有自己的析构函数。

### <a name="Rc-dtor-release"></a>C.31: 类所获取的所有资源，必须都在类的析构函数中进行释放

##### 理由

避免资源泄漏，尤其是错误情形中。

##### 注解

对于以具有完整的默认操作集合的类来表示的资源来说，这些都是会自动发生的。

##### 示例

    class X {
        ifstream f;   // 可能会拥有某个文件
        // ... 没有任何定义或者声明为 =deleted 的默认操作 ...
    };

`X` 的 `ifstream` 会在其所在 `X` 的销毁时，隐含地关闭任何可能已经被它所打开的文件。

##### 示例，不好

    class X2 {     // 不好
        FILE* f;   // 可能会拥有某个文件
        // ... 没有任何定义或者声明为 =deleted 的默认操作 ...
    };

`X2` 可能会泄漏文件的句柄。

##### 注解

不过关不掉的 socket 怎么办呢？析构函数、close 以及清理操作[不应当失败](#Rc-dtor-fail)。
如果它确实这样的话，就出现了一个不存在真正的好解决方案的问题。
对于新手来说，作为析构函数的编写者，无法了解析构函数是因为什么被调用的，而且不能通过抛出异常来"拒绝执行"。
参见[相关讨论](#Sd-never-fail)。
让这个问题更加糟糕的，还包括许多的 close/release 操作都是无法重试的。
许多人都曾试图解决这个问题，但仍不存在已知的一般性解决方案。
如果可能的话，可以考虑吧 close/cleanup 的失败看成是基本的设计错误，然后终止程序（terminate）。

##### 注解

类之中也可以持有指向它并不拥有的对象的指针和引用。
显然这样的对象是不应当在类的析构函数中被 `delete` 的。
例如：

    Preprocessor pp { /* ... */ };
    Parser p { pp, /* ... */ };
    Type_checker tc { p, /* ... */ };

这里的 `p` 指向 `pp` 但并不拥有它。

##### 强制实施

* 【简单】 当类中所有的指针或引用成员变量是所有者
  （比如通过使用 `gsl::owner` 所断定）时，它们就应当在析构函数中有所引用。
* 【困难】 当在所有权上没有明确的说法时，为指针或引用成员变量确定其是否是所有者
  （比如，检查构造函数的代码）。

### <a name="Rc-dtor-ptr"></a>C.32: 如果类中带有原始指针（`T*`）或者引用（`T&`），请考虑它是否是所有者

##### 理由

大量的代码都是和所有权无关的。

##### 示例

    ???

##### 注解

如果 `T*` 或 `T&` 是有所有权的，就将其标为 `owning`。如果 `T*` 没有所有权，考虑将其标为 `ptr`。
这将有助于文档和分析工作。

##### 强制实施

查看原始指针成员和引用成员的初始化，看看是否进行了分配操作。

### <a name="Rc-dtor-ptr2"></a>C.33: 如果类中带有所有权的指针成员，请定义析构函数

##### 理由

被拥有的对象，必须在拥有它的对象销毁时进行 `delete`。

##### 示例

指针成员可能表示某种资源。
[不应该这样使用 `T*`](#Rr-ptr)，但老代码中这是很常见的。
请把 `T*` 当作一种可能的所有者的嫌疑。

    template<typename T>
    class Smart_ptr {
        T* p;   // 不好: *p 的所有权含糊不清
        // ...
    public:
        // ... 没有自定义的默认操作 ...
    };
    
    void use(Smart_ptr<int> p1)
    {
        // 错误: p2.p 泄漏了（当其不为 nullptr 且未被其他代码所拥有时）
        auto p2 = p1;
    }

注意，当你定义析构函数时，你必须定义或者弃置（delete）[所有的默认操作](#Rc-five)：

    template<typename T>
    class Smart_ptr2 {
        T* p;   // 不好: *p 的所有权含糊不清
        // ...
    public:
        // ... 没有自定义的复制操作 ...
        ~Smart_ptr2() { delete p; }  // p 是所有者！
    };
    
    void use(Smart_ptr2<int> p1)
    {
        auto p2 = p1;   // 错误: 双重删除
    }

预置的复制操作仅仅把 `p1.p` 复制给了 `p2.p`，折导致对 `p1.p` 进行双重销毁。请明确所有权的处理：

    template<typename T>
    class Smart_ptr3 {
        owner<T*> p;   // OK: 明确了 *p 的所有权
        // ...
    public:
        // ...
        // ... 复制和移动操作 ...
        ~Smart_ptr3() { delete p; }
    };
    
    void use(Smart_ptr3<int> p1)
    {
        auto p2 = p1;   // OK: 未发生双重删除
    }

##### 注解

通常最简单的处理析构函数的方式，就是把指针换成一个智能指针（比如 `std::unique_ptr`），并让编译器来安排进行恰当的隐式销毁过程。

##### 注解

为什么不直接要求全部带有所有权的指针都是"智能指针"呢？
这样做有时候需要进行不平凡的代码改动，并且可能会对 ABI 造成影响。

##### 强制实施

* 怀疑带有指针数据成员的类。
* 带有 `owner<T>` 的类应当定义其默认操作。


### <a name="Rc-dtor-virtual"></a>C.35: 基类的析构函数应当要么是 public 和 virtual，要么是 protected 且非 virtual

##### 理由

以防止未定义行为。
若析构函数是 public，调用方代码就可以尝试通过基类指针来销毁一个派生类的对象，而如果基类的析构函数是非 virtual，则其结果是未定义的。
若析构函数是 protected，调用方代码就无法通过基类指针进行销毁，而且这个析构函数不需要是 virtual；它应当是 protected 而不是 private，以便它能够在派生类析构函数中执行。
总之，基类的编写者并不知道什么是当进行销毁时要做的适当操作。

##### 探讨

请参见[这条规则](#Sd-dtor)中的探讨段落.

##### 示例，不好

    struct Base {  // 不好: 隐含带有 public 的非 virtual 析构函数
        virtual void f();
    };
    
    struct D : Base {
        string s {"a resource needing cleanup"};
        ~D() { /* ... do some cleanup ... */ }
        // ...
    };
    
    void use()
    {
        unique_ptr<Base> p = make_unique<D>();
        // ...
    } // p 的销毁调用了 ~Base() 而不是 ~D()，这导致 D::s 的泄漏，也许不止

##### 注解

虚函数针对派生类定义了一个接口，使用它并不需要对派生类有所了解。
如果这个接口允许进行销毁，那么它应当安全地做到这点。

##### 注解

析构函数必须是非私有的，否则它会妨碍使用这个类型：

    class X {
        ~X();   // 私有析构函数
        // ...
    };
    
    void use()
    {
        X a;                        // 错误: 无法销毁
        auto p = make_unique<X>();  // 错误: 无法销毁
    }

##### 例外

可以构想出一种可能需要受保护虚析构函数的情形：派生类型（且仅限于这种类型）的对象允许通过基类指针来销毁*另一个*对象（而不是其自身）。不过我们在实际中从未见到过这种情况。


##### 强制实施

* 带有任何虚函数的类的析构函数，应当要么是 public virtual，要么是 protected 且非 virtual。

### <a name="Rc-dtor-fail"></a>C.36: 析构函数不能失败

##### 理由

一般来说当析构函数可能失败时我们不知道怎样写出没有错误的代码。
标准库要求它所处理的所有的类所带有的析构函数都应当不会因抛出异常而退出。

##### 示例

    class X {
    public:
        ~X() noexcept;
        // ...
    };
    
    X::~X() noexcept
    {
        // ...
        if (cannot_release_a_resource) terminate();
        // ...
    }

##### 注解

许多人都曾试图针对析构函数中的故障处理设计一种傻瓜式的方案。
但没有人得到过任何一种通用方案。
这确实是真正的实际问题：比如说，怎么处理无法关闭的 socket？
析构函数的编写者无法了解析构函数为什么会被调用，并且不能通过抛出异常来"拒绝执行"。
参见[探讨](#Sd-never-fail)段落。
让问题更麻烦的是，许多的"关闭/释放"操作还都是不能重试的。
如果确实可行的话，请把"关闭/清理"的失败作为一项基本设计错误并终止（terminate）程序。

##### 注解

把析构函数声明为 `noexcept`。这将确保它要么正常完成执行，要么就终止程序。

##### 注解

如果一个资源无法释放而程序不能失败，请尝试把这个故障用某种方式通知给系统中的其他部分
（也许甚或修改某个全局状态，并希望有人能注意到它并有能力处理这个问题）。
请充分警惕，这种技巧是有专门用途的，并且容易出错。
请考虑"连接关闭不了"的那个例子。
这也许是因为连接的另一端出现了问题，但只有对连接的两端同时负责的代码才能恰当地处理这个问题。
析构函数可以向系统中负责管控的部分发送一个消息（或别的什么），然后认为已经关闭了连接并正常返回。

##### 注解

如果析构函数所用的操作可能会失败的话，它可以捕获这些异常，某些时候仍然可以成功完成执行
（例如，换用与抛出异常的清理机制不同的另一种机制）。

##### 强制实施

【简单】 如果析构函数可能抛出异常，就应当将其声明为 `noexcept`。

### <a name="Rc-dtor-noexcept"></a>C.37: 使析构函数 `noexcept`

##### 理由

[析构函数不能失败](#Rc-dtor-fail)。如果析构函数试图抛出异常来退出，这就是一种设计错误，程序最好终止执行。

##### 注解

当类中的所有成员都带有 `noexcept` 析构函数时，析构函数（无论是自定义的还是编译器生成的）将被隐含地声明为 `noexcept`（这与其函数体中的代码无关）。通过将析构函数明确标记为 `noexcept`，程序员可以防止由于添加或修改类的成员而导致析构函数变为隐含的 `noexcept(false)`。

##### 示例

并非所有析构函数都默认为 noexcept; 一个抛出异常的成员会影响整个类的层级：

    struct X {
        Details x;  // 碰巧有一个抛出析构函数
        // ...
        ~X() { }    // 隐含地 noexcept（false）; 也可以抛出异常
    };

所以，不确定的话，声明一个析构函数 noexcept.

##### 注解

为什么对所有析构函数声明 noexcept？
因为在许多情况下，特别是简单的情况，会分散混乱。

##### 强制实施

【简单】 如果析构函数可能抛出异常，就应当将其声明为 `noexcept`。

## <a name="SS-ctor"></a>C.ctor: 构造函数

构造函数定义对象如何进行初始化（构造）。

### <a name="Rc-ctor"></a>C.40: 如果类具有不变式，请为其定义构造函数

##### 理由

这正是构造函数的用途。

##### 示例

    class Date {  // Date 表示从 1900/1/1 到 2100/12/31 范围中
                  // 的一个有效日期
        Date(int dd, int mm, int yy)
            :d{dd}, m{mm}, y{yy}
        {
            if (!is_valid(d, m, y)) throw Bad_date{};  // 不变式的实施
        }
        // ...
    private:
        int d, m, y;
    };

把不变式表达为构造函数上的一个 `Ensures` 通常是一种好做法。

##### 注解

即便类并没有不变式，也可以用构造函数来简化代码。例如：

    struct Rec {
        string s;
        int i {0};
        Rec(const string& ss) : s{ss} {}
        Rec(int ii) :i{ii} {}
    };
    
    Rec r1 {7};
    Rec r2 {"Foo bar"};

##### 注解

C++11 的初始化式列表规则免除了对许多构造函数的需求。例如：

    struct Rec2{
        string s;
        int i;
        Rec2(const string& ss, int ii = 0) :s{ss}, i{ii} {}   // 多余的
    };
    
    Rec2 r1 {"Foo", 7};
    Rec2 r2 {"Bar"};

`Rec2` 的构造函数是多余的。
同样的，`int` 的默认值最好用[成员初始化式](#Rc-in-class-initializer)来给出。

**参见**: [构造有效对象](#Rc-complete)和[构造函数抛出异常](#Rc-throw)。

##### 强制实施

* 对带有自定义的复制操作但没有构造函数的类进行标记（自定义的复制操作是类是否带有不变式的良好指示器）

### <a name="Rc-complete"></a>C.41: 构造函数应当创建经过完整初始化的对象

##### 理由

构造函数为类设立不变式。类的使用者应当能够假定构造完成的对象是可以使用的。

##### 示例，不好

    class X1 {
        FILE* f;   // 在任何其他函数之前应当调用 init()
        // ...
    public:
        X1() {}
        void init();   // 初始化 f
        void read();   // 从 f 中读取数据
        // ...
    };
    
    void f()
    {
        X1 file;
        file.read();   // 程序崩溃或者错误的数据读取！
        // ...
        file.init();   // 太晚了
        // ...
    }

编译器读不懂代码注释。

##### 例外

如果无法方便地通过构造函数来构造有效的对象的话，请[使用工厂函数](#Rc-factory)。

##### 强制实施

* 【简单】 每个构造函数都应当对每个成员变量进行初始化（明确地，通过委派构造函数调用，或者通过默认构造）。
* 【未知】 如果构造函数带有 `Ensures` 契约的话，尝试确定它给出的是否是一项后条件。

##### 注解

如果构造函数（为创建有效的对象）获取了某个资源，则这个资源应当[由析构函数释放](#Rc-dtor-release)。
这种以构造函数获取资源并以析构函数来释放的惯用法被称为 [RAII](#Rr-raii)（"资源获取即初始化/Resource Acquisition Is Initialization"）。

### <a name="Rc-throw"></a>C.42: 当构造函数无法构造有效对象时，应当抛出异常

##### 理由

留下无效对象不管就是会造成麻烦的做法。

##### 示例

    class X2 {
        FILE* f;
        // ...
    public:
        X2(const string& name)
            :f{fopen(name.c_str(), "r")}
        {
            if (!f) throw runtime_error{"could not open" + name};
            // ...
        }
    
        void read();      // 从 f 中读取数据
        // ...
    };
    
    void f()
    {
        X2 file {"Zeno"}; // 当文件打不开时会抛出异常
        file.read();      // 好的
        // ...
    }

##### 示例，不好

    class X3 {     // 不好: 构造函数留下了无效的对象
        FILE* f;   // 在任何其他函数之前应当调用 is_valid()
        bool valid;
        // ...
    public:
        X3(const string& name)
            :f{fopen(name.c_str(), "r")}, valid{false}
        {
            if (f) valid = true;
            // ...
        }
    
        bool is_valid() { return valid; }
        void read();   // 从 f 中读取数据
        // ...
    };
    
    void f()
    {
        X3 file {"Heraclides"};
        file.read();   // 程序崩溃或错误的数据读取！
        // ...
        if (file.is_valid()) {
            file.read();
            // ...
        }
        else {
            // ... 处理错误 ...
        }
        // ...
    }

##### 注解

对于变量的定义式（比如在栈上，或者作为其他对象的成员），不存在可以返回错误代码的明确函数调用。
留下无效的对象并依赖使用者能够一贯地在使用之前检查 `is_valid()` 函数是啰嗦的，易错的，并且是低效的做法。

##### 例外

有些领域，比如像飞行器控制这样的硬实时系统中，（在没有其他工具支持下）异常处理在计时方面不具有足够的可预测性。
这样的话就必须使用 `is_valid()` 技巧。这种情况下，可以一贯并即刻地检查 `is_valid()` 来模拟 [RAII](#Rr-raii)。

##### 替代方案

如果你觉得想要使用某种"构造函数之后初始化"或者"两阶段初始化"手法，请试着避免这样做。
如果你确实要如此的话，请参考[工厂函数](#Rc-factory)。

##### 注解

人们使用 `init()` 函数而不是在构造函数中进行初始化的一种原因是为了避免代码重复。
[委派构造函数](#Rc-delegating)和[默认成员初始化式](#Rc-in-class-initializer)可以更好地做到这点。
另一种原因是为了把初始化推迟到需要对象的位置；它的解决方法通常为"[直到变量可以正确进行初始化的位置再声明变量](#Res-init)"。

##### 强制实施

???

### <a name="Rc-default0"></a>C.43: 保证可复制（值类型）类带有默认构造函数

##### 理由

许多的语言和程序库设施都依赖于默认构造函数来初始化其各个元素，比如 `T a[10]` 和 `std::vector<T> v(10)`。
对于同时是可复制的类型来说，默认构造函数通常会简化定义一个适当的[移动遗留状态](#???)的任务。

##### 注解

[值类型](#SS-concrete)，是可以复制（且通常也可以比较）的类型。
这与 [EoP](http://elementsofprogramming.com/) 和 [Palo Alto TR](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf) 中的正规（Regular）类型紧密相关。

##### 示例

    class Date { // 不好: 缺少默认构造函数
    public:
        Date(int dd, int mm, int yyyy);
        // ...
    };
    
    vector<Date> vd1(1000);   // 需要默认的 Date
    vector<Date> vd2(1000, Date{Month::October, 7, 1885});   // 替代方式

仅当没有用户声明的构造函数时，默认构造函数才会自动生成，因此上面的例子中的 vector `vdl` 是无法进行初始化的。
缺乏默认值会导致用户感觉奇怪，并且使其使用变复杂，因此如果可以合理定义的话就应当定义默认值。

`Date` 可以推动我们考虑：
"天然的"默认日期是不存在的（大爆炸对大多数人来说在时间上太过久远了），因此这并非是毫无意义的例子。
`{0, 0, 0}` 在大多数历法系统中都不是有效的日期，因此选用它可能会引入某种如同浮点的 `NaN` 这样的东西。
不过，大多数现实的 `Date` 类都有某个"首日"（比如很常见的 1970/1/1），因此以它为默认日期通常很容易做到。

    class Date {
    public:
        Date(int dd, int mm, int yyyy);
        Date() = default; // [参见](#Rc-default)
        // ...
    private:
        int dd = 1;
        int mm = 1;
        int yyyy = 1970;
        // ...
    };
    
    vector<Date> vd1(1000);

##### 注解

所有成员都带有默认构造函数的类，隐含得到一个默认构造函数：

    struct X {
        string s;
        vector<int> v;
    };
    
    X x; // 意为 X{{}, {}}; 即空字符串和空 vector

需要注意的是，内建类型并不会进行正确的默认构造：

    struct X {
        string s;
        int i;
    };
    
    void f()
    {
        X x;    // x.s 被初始化为空字符串; x.i 未初始化
    
        cout << x.s << ' ' << x.i << '\n';
        ++x.i;
    }

静态分配的内建类型对象被默认初始化为 `0`，但局部的内建变量并非如此。
请注意你的编译期也许默认初始化了局部内建变量，而它在优化构建中并不会这样做。
因此，上例这样的代码也许恰好可以工作，但这其实依赖于未定义的行为。
假定你确实需要初始化的话，可以使用明确的默认初始化：

    struct X {
        string s;
        int i {};   // 默认初始化（为 0）
    };

##### 注解

缺乏合理的默认构造的类，通常也都不是可以复制的，因此它们并不受本条指导方针所限。

例如，基类就不是值类型（基类不能进行复制），且因而并不需要一个默认构造函数：

    // Shape 是个抽象基类，而不是可复制的值类型
    // 它可以有也可以没有默认构造函数。
    struct Shape {
        virtual void draw() = 0;
        virtual void rotate(int) = 0;
        // =delete 复制/移动函数
        // ...
    };

必须在构造过程中获取由调用方提供的资源的类，通常无法提供默认构造函数，但它们并不受本条指导方针所限，因为这样的类通常也不是可复制的：

    // std::lock_guard 不是可复制的值类型。
    // 它没有默认构造函数。
    lock_guard g {mx};  // 护卫 mutex mx
    lock_guard g2;      // 错误：不护卫任何东西

带有必须由其成员函数或者其用户进行特殊处理的"特殊状态"的类，会带来额外的工作量，
（而且很可能有更多的错误）。这样的类型不管其是否可以复制，都可以以这个特殊状态作为其默认构造的值：

    // std::ofstream 不是可复制的值类型。
    // 它刚好有一个默认构造函数，
    // 并带来一种特殊的"未打开"状态。
    ofstream out {"Foobar"};
    // ...
    out << log(time, transaction);

一些类似的可复制的具有特殊状态的类型，比如具有特殊状态"==nullptr"的可复制的智能指针，也应该以该特殊状态作为其默认构造的值。

不过，为有意义的状态提供默认构造函数（比如 `std::string` 的 `""` 和 `std::vector` 的 `{}`），也是推荐的做法。

##### 强制实施

* 对于可用 `=` 进行复制的类，若没有默认构造函数则对其进行标记。
* 对于可用 `==` 进行比较但不可复制的类进行标记。


### <a name="Rc-default00"></a>C.44: 尽量让默认构造函数简单且不抛出异常

##### 理由

如果可以设置一个"默认"值同时又不会涉及可能失败的操作的话，就可以简化错误处理以及对移动操作的推理。

##### 示例，有问题的

    template<typename T>
    // elem 指向以 new 分配的 space-elem 个元素
    class Vector0 {
    public:
        Vector0() :Vector0{0} {}
        Vector0(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}
        // ...
    private:
        own<T*> elem;
        T* space;
        T* last;
    };

这段代码很不错而且通用，不过在发生错误之后把一个 `Vector0` 进行置空会涉及一次分配，而它是可能失败的。
而且把默认的 `Vector` 表示为 `{new T[0], 0, 0}` 也比较浪费。
比如说，`Vector0<int> v[100]` 会耗费 100 次分配操作。

##### 示例

    template<typename T>
    // elem 为 nullptr，否则 elem 指向以 new 分配的 space-elem 个元素
    class Vector1 {
    public:
        // 设置表示为 {nullptr, nullptr, nullptr}; 不会抛出异常
        Vector1() noexcept {}
        Vector1(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}
        // ...
    private:
        own<T*> elem = nullptr;
        T* space = nullptr;
        T* last = nullptr;
    };

表示为 `{nullptr, nullptr, nullptr}` 的 `Vector1{}` 很廉价，但这是一种特殊情况并且隐含了运行时检查。
在检测到错误后可以很容易地把 `Vector1` 置空。

##### 强制实施

* 标记会抛出的默认构造函数

### <a name="Rc-default"></a>C.45: 不要定义仅对数据成员进行初始化的默认构造函数；应当使用成员初始化式

##### 理由

使用类内部的成员初始化式，编译器可以据此生成函数。由编译器生成的函数可能更高效。

##### 示例，不好

    class X1 { // 不好: 未使用成员初始化式
        string s;
        int i;
    public:
        X1() :s{"default"}, i{1} { }
        // ...
    };

##### 示例

    class X2 {
        string s = "default";
        int i = 1;
    public:
        // 使用编译期生成的默认构造函数
        // ...
    };

##### 强制实施

【简单】 默认构造函数应当不只是用常量初始化成员变量。

### <a name="Rc-explicit"></a>C.46: 默认情况下，把单参数的构造函数声明为 `explicit`

##### 理由

用以避免意外的类型转换。

##### 示例，不好

    class String {
    public:
        String(int);   // 不好
        // ...
    };
    
    String s = 10;   // 意外: 大小为 10 的字符串

##### 例外

如果确实想要从构造函数参数类型隐式转换为类类型的话，就不使用 `explicit`：

    class Complex {
    public:
        Complex(double d);   // OK: 希望进行从 d 向 {d, 0} 的转换
        // ...
    };
    
    Complex z = 10.7;   // 无意外的转换

**参见**: [有关隐式转换的讨论](#Ro-conversion)

##### 注解

不应当将复制和移动构造函数作为 `explicit` 的，因为它们并不进行转换。显式的复制/移动构造函数会把按值传递和返回变麻烦。

##### 强制实施

【简单】 单参数的构造函数应当声明为 `explicit`。有益的单参数非 `explicit` 构造函数在大多数代码库中都是很少见的。对没在"已确认列表"中列出的每个违规都要给出警告。

### <a name="Rc-order"></a>C.47: 按成员声明的顺序对成员变量进行定义和初始化

##### 理由

以尽量避免混淆和错误。该顺序正是初始化的发生顺序（而这与成员初始化式的顺序无关）。

##### 示例，不好

    class Foo {
        int m1;
        int m2;
    public:
        Foo(int x) :m2{x}, m1{++x} { }   // 不好: 有误导性的初始化式顺序
        // ...
    };
    
    Foo x(1); // 意外: x.m1 == x.m2 == 2

##### 强制实施

【简单】 成员初始化式的列表中应当以成员声明的相同顺序列出各个成员。

**参见**: [讨论](#Sd-order)

### <a name="Rc-in-class-initializer"></a>C.48: 对于常量初始化式来说，优先采用类中的初始化式而不是构造函数中的成员初始化式

##### 理由

明确所有构造函数都将使用相同的值。避免重复。避免可维护性问题。这样做会产生最简短最高效的代码。

##### 示例，不好

    class X {   // 不好
        int i;
        string s;
        int j;
    public:
        X() :i{666}, s{"qqq"} { }   // j 未初始化
        X(int ii) :i{ii} {}         // s 为 "" 而 j 未初始化
        // ...
    };

维护者如何能看出 `j` 是否是故意未初始化的（尽管这可能是个糟糕的想法），而且是不是故意要使 `s` 的默认值在一种情况下为 `""` 而另一种情况下为 `qqq` 呢（几乎可以肯定是个 Bug）？这里 `j` 的问题（忘记对成员初始化）通常会出现在向现存类中添加新成员的时候。

##### 示例

    class X2 {
        int i {666};
        string s {"qqq"};
        int j {0};
    public:
        X2() = default;        // 所有成员都初始化为默认值
        X2(int ii) :i{ii} {}   // s 和 j 被初始化为默认值
        // ...
    };

**替代方案**: 也可以用构造函数的默认实参来获得一部分的好处，而且这在比较老的代码中也并不少见。不过这种方式不够直白，会导致需要传递较多的参数，并且当有多个构造函数时也会造成重复：

    class X3 {   // 不好: 不明确，参数传递开销
        int i;
        string s;
        int j;
    public:
        X3(int ii = 666, const string& ss = "qqq", int jj = 0)
            :i{ii}, s{ss}, j{jj} { }   // 所有成员都初始化为默认值
        // ...
    };

##### 强制实施

* 【简单】 每个构造函数都应该对所有成员变量进行初始化（明确进行，通过委派构造函数调用，或者通过默认构造）。
* 【简单】 构造函数的默认实参的出现表明类内部的初始化式可能更合适。

### <a name="Rc-initialize"></a>C.49: 优先进行初始化而不是在构造函数中赋值

##### 理由

初始化语法明确指出所进行的是初始化而不是赋值，它更加精炼和高效。这样也避免了"未设值前就使用"的错误。

##### 示例，好

    class A {   // 好
        string s1;
    public:
        A(czstring p) : s1{p} { }    // 好: 直接构造（这里明确指名了 C 风格字符串）
        // ...
    };

##### 示例，不好

    class B {   // 不好
        string s1;
    public:
        B(const char* p) { s1 = p; }   // 不好: 执行默认构造函数之后进行赋值
        // ...
    };
    
    class C {   // 恶劣，非常不好
        int* p;
    public:
        C() { cout << *p; p = new int{10}; }   // 意外，初始化前就被使用了
        // ...
    };

##### 示例，更好的做法

可以使用 `gsl::string_span` 或者（C++17 中的）`std::string_view` 代替这些 `const char*`
来作为[一种表示函数实参的更通用的方式](#Rstr-view)：

    class D {   // 好
        string s1;
    public:
        A(string_view v) : s1{v} { }    // 好: 直接构造
        // ...
    };

### <a name="Rc-factory"></a>C.50: 当初始化过程中需要体现"虚函数行为"时，请使用工厂函数

##### 理由

当基类对象的状态必须依赖于对象的派生部分的状态时，需要使用虚函数（或等价手段），并最小化造成误用和不完全构造的对象的机会窗口。

##### 注解

工厂的返回类型默认情况下通常应当为 `unique_ptr`；如果某些用法需要共享，则调用方可以将这个 `unique_ptr` `move` 到一个 `shared_ptr` 中。但是，如果工厂的作者已知其所返回的对象的所有用法都是共享使用的话，就可返回 `shared_ptr`，并在函数体中使用 `make_shared` 以节省一次分配。

##### 示例，不好

    class B {
    public:
        B() {
            /* ... */
            f(); // 不好: C.82：不要在构造函数和析构函数中调用虚函数
            /* ... */
        }
    
        virtual void f() = 0;
    };

##### 示例

    class B {
    protected:
        class Token {};
    
    public:
        explicit B(Token) { /* ... */ }  // 创建不完全初始化的对象
        virtual void f() = 0;
    
        template<class T>
        static shared_ptr<T> create()    // 创建共享对象的接口
        {
            auto p = make_shared<T>(typename T::Token{});
            p->post_initialize();
            return p;
        }
    
    protected:
        virtual void post_initialize()   // 构造之后立即调用
            { /* ... */ f(); /* ... */ } // 好: 虚函数分派是安全的
    };
    
    class D : public B {                 // 某个派生类
    protected:
        class Token {};
    
    public:
        explicit D(Token) : B( B::Token{} ) {}
        void f() override { /* ... */ };
    
    protected:
        template<class T>
        friend shared_ptr<T> B::create();
    };
    
    shared_ptr<D> p = D::create<D>();  // 创建一个 D 的对象

`make_shared` 要求公开的构造函数。构造函数通过要求一个受保护的 `Token` 而无法再被公开调用，从而避免不完全构造的对象泄漏出去。
通过提供工厂函数 `create()`，（在自由存储上）构造对象变得简便。

##### 注解

根据惯例，工厂方法在自由存储上进行分配，而不是在运行栈或者某个外围对象之内进行。

**参见**: [讨论](#Sd-factory)

### <a name="Rc-delegating"></a>C.51: 用委派构造函数来表示类中所有构造函数的共同行为

##### 理由

以避免代码重复和意外出现的差异。

##### 示例，不好

    class Date {   // 不好: 有重复
        int d;
        Month m;
        int y;
    public:
        Date(int dd, Month mm, year yy)
            :d{dd}, m{mm}, y{yy}
            { if (!valid(d, m, y)) throw Bad_date{}; }
    
        Date(int dd, Month mm)
            :d{dd}, m{mm} y{current_year()}
            { if (!valid(d, m, y)) throw Bad_date{}; }
        // ...
    };

写这些共同行为很啰嗦，而且可能意外出现不一致。

##### 示例

    class Date2 {
        int d;
        Month m;
        int y;
    public:
        Date2(int dd, Month mm, year yy)
            :d{dd}, m{mm} y{yy}
            { if (!valid(d, m, y)) throw Bad_date{}; }
    
        Date2(int dd, Month mm)
            :Date2{dd, mm, current_year()} {}
        // ...
    };

**参见**: 当"重复行为"是简单的初始化时，考虑使用[类内部的成员初始化式](#Rc-in-class-initializer)。

##### 强制实施

【中等】 查找相似的构造函数体。

### <a name="Rc-inheriting"></a>C.52: 使用继承构造函数来把构造函数引入到无须进行其他的明确初始化操作的派生类之中

##### 理由

当派生类需要这些构造函数时，重新实现它们既啰嗦又容易出错。

##### 示例

`std::vector` 有许多棘手的构造函数，如果我想要创建自己的 `vector` 的话，我并不想重新实现它们：

    class Rec {
        // ... 数据，以及许多不错的构造函数 ...
    };
    
    class Oper : public Rec {
        using Rec::Rec;
        // ... 没有数据成员 ...
        // ... 许多不错的工具函数 ...
    };

##### 示例，不好

    struct Rec2 : public Rec {
        int x;
        using Rec::Rec;
    };
    
    Rec2 r {"foo", 7};
    int val = r.x;   // 未初始化

##### 强制实施

确保派生类的每个成员都被初始化。

## <a name="SS-copy"></a>C.copy: 复制和移动

值类型一般都应当是可以复制的，而类层次中的接口则不应如此。
资源包装可以复制也可以不能复制。
我们可以基于逻辑因素，也可以为性能原因而将类型定义为可移动的。

### <a name="Rc-copy-assignment"></a>C.60: 使复制赋值非 `virtual`，接受 `const&` 的参数，并返回非 `const` 的引用

##### 理由

这样做简单且高效。如果想对右值进行优化，则可以提供一个接受 `&&` 的重载（参见 [F.18](#Rf-consume)）。

##### 示例

    class Foo {
    public:
        Foo& operator=(const Foo& x)
        {
            // 好: 不需要检查自赋值的情况（除非为性能考虑）
            auto tmp = x;
            swap(tmp); // 参见 C.83
            return *this;
        }
        // ...
    };
    
    Foo a;
    Foo b;
    Foo f();
    
    a = b;    // 用左值赋值：复制
    a = f();  // 用右值赋值：可能进行移动

##### 注解

`swap` 实现技巧可以提供[强保证](#Abrahams01)。

##### 示例

如果不产生临时副本能够得到明显好得多的性能的话应当怎么办呢？考虑一个简单的 `Vector` 类，其所使用的领域中常常要对大型的、大小相同的 `Vector` 进行赋值。这种情况下，`swap` 实现技巧中所蕴含的元素复制操作将导致运行成本按数量级增长。

    template<typename T>
    class Vector {
    public:
        Vector& operator=(const Vector&);
        // ...
    private:
        T* elem;
        int sz;
    };
    
    Vector& Vector::operator=(const Vector& a)
    {
        if (a.sz > sz) {
            // ... 使用 swap 技巧，没有更好的方式了 ...
            return *this;
        }
        // ... 从 *a.elem 复制 sz 个元素给 elem ...
        if (a.sz < sz) {
            // ... 销毁 *this 中过剩的元素并调整大小 ...
        }
        return *this;
    }

直接向目标元素中进行写入的话，我们得到的是[基本保证](#Abrahams01)而不是 `swap` 技巧所提供的强保证。还要当心[自赋值](#Rc-copy-self)。

**替代方案**: 如果你想要 `virtual` 的赋值运算符，并了解为何这样做很有问题的话，请不要使其为 `operator=`。请使用一个命名函数，如 `virtual void assign(const Foo&)`。
参见[复制构造函数 vs. `clone()`](#Rc-copy-virtual)。

##### 强制实施

* 【简单】 赋值运算符不能为 `virtual`。有怪兽出没！
* 【简单】 赋值运算符应当返回 `T&` 以支持调用链，不要改为如 `const T&` 等类型，这样会影响可组合性以及把对象放入容器的能力。
* 【中等】 赋值运算符应当（隐式或者显式）调用所有的基类和成员的赋值运算符。
  检查析构函数以分辨类型具有指针语义还是值语义。

### <a name="Rc-copy-semantic"></a>C.61: 复制操作应当进行复制

##### 理由

这正是一般假定所具有的语义。执行 `x = y` 之后，应当有 `x == y`。
进行复制之后，`x` 和 `y` 可以是各自独立的对象（值语义，非指针的内建类型和标准库类型的工作方式），也可以代表某个共享的对象（指针语义，就是指针的工作方式）。

##### 示例

    class X {   // OK: 值语义
    public:
        X();
        X(const X&);     // 复制 X
        void modify();   // 改变 X 的值
        // ...
        ~X() { delete[] p; }
    private:
        T* p;
        int sz;
    };
    
    bool operator==(const X& a, const X& b)
    {
        return a.sz == b.sz && equal(a.p, a.p + a.sz, b.p, b.p + b.sz);
    }
    
    X::X(const X& a)
        :p{new T[a.sz]}, sz{a.sz}
    {
        copy(a.p, a.p + sz, p);
    }
    
    X x;
    X y = x;
    if (x != y) throw Bad{};
    x.modify();
    if (x == y) throw Bad{};   // 假定具有值语义

##### 示例

    class X2 {  // OK: 指针语义
    public:
        X2();
        X2(const X2&) = default; // 浅拷贝
        ~X2() = default;
        void modify();          // 改变所指向的值
        // ...
    private:
        T* p;
        int sz;
    };
    
    bool operator==(const X2& a, const X2& b)
    {
        return a.sz == b.sz && a.p == b.p;
    }
    
    X2 x;
    X2 y = x;
    if (x != y) throw Bad{};
    x.modify();
    if (x != y) throw Bad{};  // 假定具有指针语义

##### 注解

应当优先采用值语义，除非你要构建某种"智能指针"。值语义是最容易进行推理的，而且也是被标准库设施所期望的。

##### 强制实施

【无法强制实施】

### <a name="Rc-copy-self"></a>C.62: 使复制赋值可以安全进行自赋值

##### 理由

如果 `x=x` 会改变 `x` 的值的话，会让人惊异，并导致发生严重的错误（通常会含有资源泄漏）。

##### 示例

标准库的容器类都能优雅且高效地处理自赋值：

    std::vector<int> v = {3, 1, 4, 1, 5, 9};
    v = v;
    // v 的值仍然是 {3, 1, 4, 1, 5, 9}

##### 注解

从可以处理自赋值的成员所生成的默认复制操作是能够正确处理自赋值的。

    struct Bar {
        vector<pair<int, int>> v;
        map<string, int> m;
        string s;
    };
    
    Bar b;
    // ...
    b = b;   // 正确而且高效

##### 注解

可以通过明确检测自赋值来处理自赋值的情况，不过通常不进行这种检测会变得更快并且更优雅（比如说，[利用 `swap`](#Rc-swap)）。

    class Foo {
        string s;
        int i;
    public:
        Foo& operator=(const Foo& a);
        // ...
    };
    
    Foo& Foo::operator=(const Foo& a)   // OK，但增加了成本
    {
        if (this == &a) return *this;
        s = a.s;
        i = a.i;
        return *this;
    }

这显然是安全的，也貌似高效。
不过，如果一百万次赋值才会做一次自赋值会怎么样呢？
这样就有大约一百万次多余的测试（不过由于基本上每次的答案都相同，计算机的分支预测电路也基本上每次都会猜对）。
考虑：

    Foo& Foo::operator=(const Foo& a)   // 更简单，而且可能也更好
    {
        s = a.s;
        i = a.i;
        return *this;
    }

`std::string` 的自赋值是安全的，`int` 也是如此。所有的成本都将花在（罕见的）自赋值情况中。

##### 强制实施

【简单】 赋值运算符不应当包含 `if (this == &a) return *this;` 这样的代码模式 ???

### <a name="Rc-move-assignment"></a>C.63: 使移动赋值非 `virtual`，接受 `&&` 的参数，并返回非 `const` 的引用

##### 理由

这样简单而且高效。

**参见**: [针对复制赋值的规则](#Rc-copy-assignment)。

##### 强制实施

和针对[复制赋值](#Rc-copy-assignment)所做的相同。

* 【简单】 赋值运算符不能为 `virtual`。有怪兽出没！
* 【简单】 赋值运算符应当返回 `T&` 以支持调用链，不要改为如 `const T&` 等类型，这样会影响可组合性以及把对象放入容器的能力。
* 【中等】 移动赋值运算符应当（隐式或者显式）调用所有的基类和成员的移动赋值运算符。

### <a name="Rc-move-semantic"></a>C.64: 移动操作应当进行移动，并使原对象处于有效状态

##### 理由

这正是一般假定所具有的语义。
执行 `y=std::move(x)` 之后，`y` 的值应当为 `x` 曾经的值，而 `x` 应当处于有效状态。

##### 示例

    template<typename T>
    class X {   // OK: 值语义
    public:
        X();
        X(X&& a) noexcept;  // 移动 X
        void modify();     // 改变 X 的值
        // ...
        ~X() { delete[] p; }
    private:
        T* p;
        int sz;
    };


    X::X(X&& a)
        :p{a.p}, sz{a.sz}  // 窃取其表示
    {
        a.p = nullptr;     // 设其为"空"
        a.sz = 0;
    }
    
    void use()
    {
        X x{};
        // ...
        X y = std::move(x);
        x = X{};   // OK
    } // OK: x 可以销毁

##### 注解

理想情况下，被移走的对象应当为类型的默认值。
请确保体现这点，除非有非常好的理由不这样做。
然而，并非所有类型都有默认值，而有些类型建立默认值则是昂贵操作。
标准所要求的仅仅是被移走的对象应当可以被销毁。
我们通常也可以轻易且廉价地做得更好一些：标准库假定它可以向被移走的对象进行赋值。
请保证总是让被移走的对象处于某种（需要明确的）有效状态。

##### 注解

请让 `x = std::move(y); y = z;` 按照惯例约定的语义工作，除非有某个十分强大的理由不这样做。

##### 强制实施

【无法强制实施】 检查移动操作中对成员的赋值。如果有默认构造函数的话，则把这些赋值和默认构造函数中的初始化之间进行比较。

### <a name="Rc-move-self"></a>C.65: 使移动赋值可以安全进行自赋值

##### 理由

如果 `x = x` 会改变 `x` 的值的话，会让人惊异，并导致发生严重的错误（通常会含有资源泄漏）。不过，通常不会有人写出能够变成移动操作的自赋值代码，但它确实是会发生的。不管怎样，`std::swap` 就是利用移动操作来实现的，因此如果你不小心写了 `swap(a, b)` 而 `a` 和 `b` 指代相同的对象的话，未能处理自移动情况将是一种严重而且微妙的错误。

##### 示例

    class Foo {
        string s;
        int i;
    public:
        Foo& operator=(Foo&& a);
        // ...
    };
    
    Foo& Foo::operator=(Foo&& a) noexcept  // OK，但增加了成本
    {
        if (this == &a) return *this;  // 这行是多余的
        s = std::move(a.s);
        i = a.i;
        return *this;
    }

[自赋值](#Rc-copy-self)中反对 `if (this == &a) return *this;` 测试的"每一百万次有一次"的论点，在自移动的情况中更加适当。

##### 注解

并不存在已知的通用方法，以在移动赋值中避免进行 `if (this == &a) return *this;` 测试，又能使其得到正确的结果（亦即，执行 `x = x` 之后不改变 `x` 的值）。

##### 注解

ISO 标准中对标准库容器类仅仅保证了"有效但未指明"的状态。貌似这样做在差不多十年的实验性和产品级代码的使用中并未造成什么问题。如果你找到了反例的话，请联系各位编辑。本条规则更多的是提醒小心并强调完全的安全性。

##### 示例

下面是一种不进行测试而移动一个指针的方法（请想象这段代码来自某个移动赋值的实现）：

    // 从 other.ptr 移动到 this->ptr
    T* temp = other.ptr;
    other.ptr = nullptr;
    delete ptr;
    ptr = temp;

##### 强制实施

* 【中级】 在自赋值的情况中，移动赋值运算符不应当使持有已经被 `delete` 或设为 `nullptr` 的指针成员。
* 【无法强制实施】 查看标准库容器类型（包括 `string`）的使用方式，在普通（非性命攸关）使用中将它们当作是安全的。

### <a name="Rc-move-noexcept"></a>C.66: 使移动操作 `noexcept`

##### 理由

能够抛出异常的移动操作将违反大多数人的合理假设。
不会抛出异常的移动操作可以更高效地被标准库和语言设施所利用。

##### 示例

    template<typename T>
    class Vector {
    public:
        Vector(Vector&& a) noexcept :elem{a.elem}, sz{a.sz} { a.sz = 0; a.elem = nullptr; }
        Vector& operator=(Vector&& a) noexcept { elem = a.elem; sz = a.sz; a.sz = 0; a.elem = nullptr; }
        // ...
    private:
        T* elem;
        int sz;
    };

这些操作不会抛出异常。

##### 示例，不好

    template<typename T>
    class Vector2 {
    public:
        Vector2(Vector2&& a) { *this = a; }             // 直接利用复制操作
        Vector2& operator=(Vector2&& a) { *this = a; }  // 直接利用复制操作
        // ...
    private:
        T* elem;
        int sz;
    };

`Vector2` 不仅低效，而且由于向量的复制需要分配内存而使其可能抛出异常。

##### 强制实施

【简单】 移动操作应当被标为 `noexcept`。

### <a name="Rc-copy-virtual"></a>C.67: 多态类应当抑制复制操作

##### 理由

*多态类*是定义或继承了至少一个虚函数的类。它很可能要被用作其他具有多态行为的派生类的基类。如果不小心将其按值传递了，如果它带有隐式生成的复制构造函数和赋值的话，它就面临发生切片的风险：只会复制派生类对象的基类部分，但将损坏其多态行为。

##### 示例，不好

    class B { // 不好: 多态基类并未抑制复制操作
    public:
        virtual char m() { return 'B'; }
        // ... 没有提供复制操作，使用预置实现 ...
    };
    
    class D : public B {
    public:
        char m() override { return 'D'; }
        // ...
    };
    
    void f(B& b) {
        auto b2 = b; // 啊呀，对象切片了；b2.m() 将返回 'B'
    }
    
    D d;
    f(d);

##### 示例

    class B { // 好: 多态类抑制了复制操作
    public:
        B(const B&) = delete;
        B& operator=(const B&) = delete;
        virtual char m() { return 'B'; }
        // ...
    };
    
    class D : public B {
    public:
        char m() override { return 'D'; }
        // ...
    };
    
    void f(B& b) {
        auto b2 = b; // ok，编译器能够检测到不恰当的复制并给出警告
    }
    
    D d;
    f(d);

##### 注解

当需要创建多态对象的深拷贝副本时，应当使用 `clone()` 函数：参见 [C.130](#Rh-copy)。

##### 例外

表示异常对象的类应当既是多态的，也可以进行复制构造。

##### 强制实施

* 对带有未弃置的复制操作的多态类进行标记。
* 对多态类对象的赋值操作进行标记。

## C.other: 默认操作的其他规则

除了语言为之提供默认实现的操作之外，
还有一些操作也是非常基础的，需要对它们的定义进行规范：
比较，`swap`，以及 `hash`。

### <a name="Rc-eqdefault"></a>C.80: 当需要明确使用缺省语义时，使用 `=default`

##### 理由

编译器能更正确地实现缺省语义，你所实现的这些函数也不会比编译器更好。

##### 示例

    class Tracer {
        string message;
    public:
        Tracer(const string& m) : message{m} { cerr << "entering " << message << '\n'; }
        ~Tracer() { cerr << "exiting " << message << '\n'; }
    
        Tracer(const Tracer&) = default;
        Tracer& operator=(const Tracer&) = default;
        Tracer(Tracer&&) = default;
        Tracer& operator=(Tracer&&) = default;
    };

由于定义了析构函数，所以也得定义它的复制和移动操作。最佳且最简单的做法就是 `= default`。

##### 示例，不好

    class Tracer2 {
        string message;
    public:
        Tracer2(const string& m) : message{m} { cerr << "entering " << message << '\n'; }
        ~Tracer2() { cerr << "exiting " << message << '\n'; }
    
        Tracer2(const Tracer2& a) : message{a.message} {}
        Tracer2& operator=(const Tracer2& a) { message = a.message; return *this; }
        Tracer2(Tracer2&& a) :message{a.message} {}
        Tracer2& operator=(Tracer2&& a) { message = a.message; return *this; }
    };

把复制和移动操作的函数体写明的做法，既啰嗦又乏味，而且易于出错。编译器则能干得更好。

##### 强制实施

【中级】 特殊操作的函数体不应当和编译器生成的版本具有同样的访问性和语义，因为这样做是多余的。

### <a name="Rc-delete"></a>C.81: 当需要关闭缺省行为（且不需要替代的行为）时，使用 `=delete`

##### 理由

少数情况下是不需要提供默认操作的。

##### 示例

    class Immortal {
    public:
        ~Immortal() = delete;   // 不允许进行销毁
        // ...
    };
    
    void use()
    {
        Immortal ugh;   // 错误: ugh 无法销毁
        Immortal* p = new Immortal{};
        delete p;       // 错误: 无法销毁 *p
    }

##### 示例

`unique_ptr` 可以移动但不能复制。为达成这点，其复制操作是被弃置的。为了避免发生复制，需要将其从左值进行复制的操作定义为 `=delete`：

    template <class T, class D = default_delete<T>> class unique_ptr {
    public:
        // ...
        constexpr unique_ptr() noexcept;
        explicit unique_ptr(pointer p) noexcept;
        // ...
        unique_ptr(unique_ptr&& u) noexcept;   // 移动构造函数
        // ...
        unique_ptr(const unique_ptr&) = delete; // 关闭从左值进行的复制
        // ...
    };
    
    unique_ptr<int> make();   // 创建"某个对象"并以移动方式返回
    
    void f()
    {
        unique_ptr<int> pi {};
        auto pi2 {pi};      // 错误: 不存在从左值进行的移动构造函数
        auto pi3 {make()};  // OK，进行移动: make() 的结果为右值
    }

注意，弃置的函数应当是公开的。

##### 强制实施

消除一个默认操作，是（应当是）基于类所要达成的语义考虑的。应当对这样的类保持怀疑，但可以维护一个"确认列表"，由人工断言其语义是正确的。

### <a name="Rc-ctor-virtual"></a>C.82: 不要在构造函数和析构函数中调用虚函数

##### 理由

其中所调用的函数其实是目前所构造的对象的函数，而不是可能在派生类中覆盖它的函数。
这可能是最易混淆的。
更糟的是，从构造函数或析构函数中直接或间接调用未被实现的纯虚函数的话，还会导致未定义的行为。

##### 示例，不好

    class Base {
    public:
        virtual void f() = 0;   // 未实现
        virtual void g();       // 有 Base 版本的实现
        virtual void h();       // 有 Base 版本的实现
        virtual ~Base();        // 有 Base 版本的实现
    };
    
    class Derived : public Base {
    public:
        void g() override;   // 提供 Derived 版本的实现
        void h() final;      // 提供 Derived 版本的实现
    
        Derived()
        {
            // 不好: 试图调用未经事先的虚函数
            f();
    
            // 不好: 想要调用 derived::g，但并未发生虚函数分派
            g();
    
            // 好: 明确说明想要调用的就是写明的版本
            Derived::g();
    
            // ok，不需要进行限定，h 为 final
            h();
        }
    };

注意，调用一个明确限定的函数时，即便函数是 `virtual` 的，也不会发生虚函数调用。

**参见** [工厂函数](#Rc-factory)，以了解如何获得调用派生类函数的效果又不会引发未定义行为。

##### 注解

其实在构造函数和析构函数中调用虚函数并不存在固有的错误。
这种调用的语义是类型安全的。
然而，经验表明这种调用很少真正需要，易于让维护者混淆，而且当被新手使用之后还会成为一种错误来源。

##### 强制实施

* 标记构造函数和析构函数中对虚函数的调用。

### <a name="Rc-swap"></a>C.83: 考虑为值类型提供 `noexcept` 的 `swap` 函数

##### 理由

`swap` 对于实现许多惯用法都很有用，其范围包括从平滑地进行对象移动，到轻易实现提供了受保证的提交功能的赋值操作以允许编写具有强异常安全性的调用代码。考虑利用 `swap` 来基于复制构造实现复制赋值操作。另见[析构函数，回收，以及 `swap` 不允许失败](#Re-never-fail)。

##### 示例，好

    class Foo {
    public:
        void swap(Foo& rhs) noexcept
        {
            m1.swap(rhs.m1);
            std::swap(m2, rhs.m2);
        }
    private:
        Bar m1;
        int m2;
    };

为调用者方便起见，可以在类型所在的相同命名空间中提供一个非成员的 `swap` 函数。

    void swap(Foo& a, Foo& b)
    {
        a.swap(b);
    }

##### 强制实施

* 【简单】 没有虚函数的类应当声明 `swap` 成员函数。
* 【简单】 当类带有 `swap` 成员函数时，它应当被声明为 `noexcept`。

### <a name="Rc-swap-fail"></a>C.84: `swap` 函数不应当失败

##### 理由

`swap` 广泛地以假定永不失败的方式被使用，而且如果存在可能失败的 `swap` 函数的话，程序也很难编写为可以正确工作。如果元素类型的 `swap` 会失败的话，标准库的容器和算法也无法正确工作。

##### 示例，不好

    void swap(My_vector& x, My_vector& y)
    {
        auto tmp = x;   // 复制各元素
        x = y;
        y = tmp;
    }

这样做不仅很慢，而且如果为 `tmp` 中的元素进行了内存分配的话，这个 `swap` 也可能抛出异常，并导致使用它的 STL 算法的失败。

##### 强制实施

【简单】 当类带有 `swap` 成员函数时，它应当被声明为 `noexcept`。

### <a name="Rc-swap-noexcept"></a>C.85: 使 `swap` 函数 `noexcept`

##### 理由

[`swap` 不应当失败](#Rc-swap-fail)。
如果 `swap` 试图用异常来退出的话，这就是严重的设计错误，程序最好理解终止 terminate。

##### 强制实施

【简单】 当类带有 `swap` 成员函数时，它应当被声明为 `noexcept`。

### <a name="Rc-eq"></a>C.86: 使 `==` 对操作数的类型对称，并使之 `noexcept`

##### 理由

不对称的操作数是出人意料的，而且当可能发生类型转换时也是一种错误来源。
`==` 是一项基础操作，程序员应当能够随意使用而不担心失败。

##### 示例

    struct X {
        string name;
        int number;
    };
    
    bool operator==(const X& a, const X& b) noexcept {
        return a.name == b.name && a.number == b.number;
    }

##### 示例，不好

    class B {
        string name;
        int number;
        bool operator==(const B& a) const {
            return name == a.name && number == a.number;
        }
        // ...
    };

`B` 的比较函数接受其第二个操作数上的类型转换，但第一个操作数不可以。

##### 注解

如果类带有比如 `double` 的 `NaN` 这样的故障状态的话，就诱惑人们让与故障状态之间的比较抛出异常。
其替代方案是让两个故障状态的比较相等，而任何有效状态和故障状态的比较都不相等。

##### 注解

本条规则适用于所有的常规比较运算符：`!=`，`<`，`<=`，`>`，以及 `>=`。

##### 强制实施

* 对两个参数类型不同的 `operator==()` 进行标记；其他比较运算符也是如此：`!=`，`<`，`<=`，`>`，和 `>=`。
* 对成员 `operator==()` 进行标记；其他比较运算符也是如此：`!=`，`<`，`<=`，`>`，和 `>=`。

### <a name="Rc-eq-base"></a>C.87: 请当心基类的 `==`

##### 理由

为类层次编写一个傻瓜式的并且有用处的 `==` 是相当困难的。

##### 示例，不好

    class B {
        string name;
        int number;
        virtual bool operator==(const B& a) const
        {
             return name == a.name && number == a.number;
        }
        // ...
    };

`B` 的比较函数接受对其第二个操作数的类型转换，但第一个则并非如此。

    class D :B {
        char character;
        virtual bool operator==(const D& a) const
        {
            return name == a.name && number == a.number && character == a.character;
        }
        // ...
    };
    
    B b = ...
    D d = ...
    b == d;    // 比较了 name 和 number，但忽略了 d 的 character
    d == b;    // 错误: 未定义 ==
    D d2;
    d == d2;   // 比较了 name、number 和 character
    B& b2 = d2;
    b2 == d;   // 比较了 name 和 number，但忽略了 d2 和 d 的 character

显然有许多使 `==` 在类层次中可以工作的方式，但不成熟的方案是无法适应范围扩展的。

##### 注解

本条规则适用于所有的常规比较运算符：`!=`，`<`，`<=`，`>`，以及 `>=`。

##### 强制实施

* 对虚的 `operator==()` 进行标记；其他比较运算符也是如此：`!=`，`<`，`<=`，`>`，和 `>=`。

### <a name="Rc-hash"></a>C.89: 使 `hash` 函数 `noexcept`

##### 理由

哈希容器的使用者都会间接地使用 `hash`，并且不会预期简单的访问操作也会抛出异常。
这是标准库的一条要求。

##### 示例，不好

    template<>
    struct hash<My_type> {  // 非常不好的 hash 特化
        using result_type = size_t;
        using argument_type = My_type;
    
        size_t operator() (const My_type & x) const
        {
            size_t xs = x.s.size();
            if (xs < 4) throw Bad_My_type{};    // "没有人期待西班牙宗教裁判所！"
            return hash<size_t>()(x.s.size()) ^ trim(x.s);
        }
    };
    
    int main()
    {
        unordered_map<My_type, int> m;
        My_type mt{ "asdfg" };
        m[mt] = 7;
        cout << m[My_type{ "asdfg" }] << '\n';
    }

如果你必须定义 `hash` 的特化的话，请尝试单纯地用 `^`（异或 xor）把标准库的 `hash` 特化进行组合。
这样做对于非专业人士来说往往会更好。

##### 强制实施

* 标记可能抛出异常的 `hash`。

### <a name="Rc-memset"></a>C.90: 依靠构造函数和赋值运算符，不要依靠 `memset` 和 `memcpy` 

##### 理由

构造某个类型的实例的标准 C++ 机制是调用其构造函数。如指导方针 [C.41](#Rc-complete) 所述：构造函数应当创建一个已完全初始化的对象。不应当需要进行如用 `memcpy` 来进行的额外初始化。
为适当地做出一个类的副本并维持类型的不变式，类型将提供复制构造函数和/或复制赋值运算符。使用 `memcpy` 来复制一个非可平凡复制的类型具有未定义的行为。这经常会导致切片，或者数据损坏。

##### 示例，好 

    struct base 
    { 
        virtual void update() = 0; 
        std::shared_ptr<int> sp; 
    }; 
    
    struct derived : public base 
    { 
        void update() override {} 
    }; 

##### 示例，不好 

    void init(derived& a) 
    { 
        memset(&a, 0, sizeof(derived)); 
    } 

这样做类型不安全并且会覆写掉虚表。

##### 示例，不好 

    void copy(derived& a, derived& b) 
    { 
        memcpy(&a, &b, sizeof(derived)); 
    } 

这样做同样类型不安全并且会覆写掉虚表。

##### 强制实施

- 对将非可平凡复制类型传递给 `memset` 或 `memcpy` 进行标记。

## <a name="SS-containers"></a>C.con: 容器和其他资源包装类

容器是一种持有某个类型的对象序列的对象；`std::vector` 就是一种典型的容器。
资源包装类是拥有某个资源的类；`std::vector` 是一种典型的资源包装类；它的资源就是其元素的序列。

容器规则概览

* [C.100: 定义容器的时候要遵循 STL](#Rcon-stl)
* [C.101: 为容器提供值语义](#Rcon-val)
* [C.102: 为容器提供移动操作](#Rcon-move)
* [C.103: 为容器提供一个初始化式列表构造函数](#Rcon-init)
* [C.104: 为容器提供一个将之置空的默认构造函数](#Rcon-empty)
* ???
* [C.109: 当资源包装类具有指针语义时，应提供 `*` 和 `->`](#Rcon-ptr)

**参见**: [资源](#S-resource)


### <a name="Rcon-stl"></a>C.100: 定义容器的时候要遵循 STL

##### 理由

大多数 C++ 程序员都熟悉 STL 容器，而且它们具有本质上十分健全的设计。

##### 注解

当然也存在其他的本质上健全的设计风格，有时候也存在不遵循
标准程序库的设计风格的各种理由，但在没有非常坚实的理由的情况下，
让实现者和用户都遵循标准，既简单又容易。

尤其是，`std::vector` 和 `std::map` 都提供了相当简单的模型。

##### 示例

    // 简化版本（比如没有分配器）：
    
    template<typename T>
    class Sorted_vector {
        using value_type = T;
        // ... 各迭代器类型 ...
    
        Sorted_vector() = default;
        Sorted_vector(initializer_list<T>);    // 初始化式列表构造函数：进行排序并存储
        Sorted_vector(const Sorted_vector&) = default;
        Sorted_vector(Sorted_vector&&) = default;
        Sorted_vector& operator=(const Sorted_vector&) = default;   // 复制赋值
        Sorted_vector& operator=(Sorted_vector&&) = default;        // 移动赋值
        ~Sorted_vector() = default;
    
        Sorted_vector(const std::vector<T>& v);   // 存储并排序
        Sorted_vector(std::vector<T>&& v);        // 排序并"窃取表示"
    
        const T& operator[](int i) const { return rep[i]; }
        // 不提供非 const 的直接访问，以维持顺序
    
        void push_back(const T&);   // 在正确位置插入（不一定在末尾）
        void push_back(T&&);        // 在正确位置插入（不一定在末尾）
    
        // ... cbegin(), cend() ...
    private:
        std::vector<T> rep;  // 用一个 std::vector 来持有各元素
    };
    
    template<typename T> bool operator==(const Sorted_vector<T>&, const Sorted_vector<T>&);
    template<typename T> bool operator!=(const Sorted_vector<T>&, const Sorted_vector<T>&);
    // ...

这段代码遵循 STL 风格但并不完整。
这种做法并不少见。
仅仅为特定的容器提供足以使其有意义的功能即可。
这里的关键在于，定义（对特定容器来说有意义的）符合约定的构造、赋值、析构函数和各迭代器
并提供它们符合约定的语义。
在此基础上，可以根据需要对这个容器进行扩展。
这里添加了来自 `std::vector` 的一些特殊构造函数。

##### 强制实施

???

### <a name="Rcon-val"></a>C.101: 为容器提供值语义

##### 理由

常规对象的理解和推理要比非常规对象更加简单。
使人感觉熟悉。

##### 注解

如果有意义的话，要使容器满足 `Regular`（概念）。
尤其是，确保对象与自身的副本比较时相等。

##### 示例

    void f(const Sorted_vector<string>& v)
    {
        Sorted_vector<string> v2 {v};
        if (v != v2)
            cout << "insanity rules!\n";
        // ...
    }

##### 强制实施

???

### <a name="Rcon-move"></a>C.102: 为容器提供移动操作

##### 理由

容器都有变大的趋势；没有移动构造函数和复制构造函数的对象
进行到处移动可以很昂贵，因而趋使人们转而传递指向它的指针，
从而带来资源管理方面的问题。

##### 示例

    Sorted_vector<int> read_sorted(istream& is)
    {
        vector<int> v;
        cin >> v;   // 假定存在向量的读取操作
        Sorted_vector<int> sv = v;  // 进行排序
        return sv;
    }

用户可以合理地假设返回一个标准程序库风格的容器是廉价的。

##### 强制实施

???

### <a name="Rcon-init"></a>C.103: 为容器提供一个初始化式列表构造函数

##### 理由

人们期望能够以一组值来初始化一个容器。
使人感觉熟悉。

##### 示例

    Sorted_vector<int> sv {1, 3, -1, 7, 0, 0}; // Sorted_vector 按需对其元素进行排序

##### 强制实施

???

### <a name="Rcon-empty"></a>C.104: 为容器提供一个将之置空的默认构造函数

##### 理由

使其满足 `Regular`。

##### 示例

    vector<Sorted_sequence<string>> vs(100);    // 100 个 Sorted_sequence，值均为 ""

##### 强制实施

???

### <a name="Rcon-ptr"></a>C.109: 当资源包装类具有指针语义时，应提供 `*` 和 `->`

##### 理由

这正是对指针所预期的行为，
使人感觉熟悉。

##### 示例

    ???

##### 强制实施

???

## <a name="SS-lambdas"></a>C.lambdas: 函数对象和 lambda

函数对象是提供了重载的 `()` 的对象，因此可以进行调用。
Lambda 表达式（通常通俗地简称为"lambda"）是一种产生函数对象的写法。
函数对象应当可廉价地复制（因此可以[按值传递](#Rf-in)）。

概要：

* [F.50: 无法用函数达成（捕捉局部变量，或者编写局部函数）时，应使用 lambda](#Rf-capture-vs-overload)
* [F.52: 在将被局部范围内使用（包括将之传递给算法）的 lambda 中优先按引用捕捉](#Rf-reference-capture)
* [F.53: 在不被局部范围内使用（包括存储在堆上，或传递给其他线程）的 lambda 中避免按引用捕捉](#Rf-value-capture)
* [ES.28: 针对复杂的初始化（尤其是 `const` 变量）使用 lambda](#Res-lambda-init)

## <a name="SS-hier"></a>C.hier: 类层次（OOP）

构建类层次（仅）用于表达一组按层次组织的概念。
基类通常都表现为接口。
类层次有两种主要的用法，它们通常被叫做实现继承和接口继承。

类层次规则概览：

* [C.120: 类层次（仅）用于表达具有天然层次化结构的概念](#Rh-domain)
* [C.121: 如果基类被用作接口的话，应使其成为纯抽象类](#Rh-abstract)
* [C.122: 当需要完全区分接口和实现时，应当用抽象类作为接口](#Rh-separation)

类层次的设计规则概览：

* [C.126: 抽象类通常并不需要构造函数](#Rh-abstract-ctor)
* [C.127: 带有虚函数的类应当带有虚的或受保护的析构函数](#Rh-dtor)
* [C.128: 虚函数应当指明 `virtual`、`override`、`final` 三者之一](#Rh-override)
* [C.129: 当设计类层次时，应区分实现继承和接口继承](#Rh-kind)
* [C.130: 多态类的深拷贝；优先采用虚函数 `clone` 来替代复制构造/赋值](#Rh-copy)
* [C.131: 避免无价值的取值和设值函数](#Rh-get)
* [C.132: 请勿无理由地使函数 `virtual`](#Rh-virtual)
* [C.133: 避免 `protected` 数据](#Rh-protected)
* [C.134: 确保所有非 `const` 数据成员有相同的访问级别](#Rh-public)
* [C.135: 用多继承来表达多个不同的接口](#Rh-mi-interface)
* [C.136: 用多继承来表达一些实现特性的合并](#Rh-mi-implementation)
* [C.137: 用 `virtual` 基类以避免过于通用的基类](#Rh-vbase)
* [C.138: 用 `using` 来为派生类和其基类建立重载集合](#Rh-using)
* [C.139: `final` 的运用应当保守](#Rh-final)
* [C.140: 不要在虚函数和其覆盖函数上提供不同的默认参数](#Rh-virtual-default-arg)

对类层次中的对象进行访问的规则概览：

* [C.145: 通过指针和引用来访问多态对象](#Rh-poly)
* [C.146: 当无法避免在类层次上进行导航时应使用 `dynamic_cast`](#Rh-dynamic_cast)
* [C.147: 当查找所需类的失败被当做一种错误时，应当对引用类型使用 `dynamic_cast`](#Rh-ref-cast)
* [C.148: 当查找所需类的失败被当做一种有效的可能情况时，应当对指针类型使用 `dynamic_cast`](#Rh-ptr-cast)
* [C.149: 用 `unique_ptr` 或 `shared_ptr` 来避免忘记对以 `new` 所创建的对象进行 `delete` 的情况](#Rh-smart)
* [C.150: 用 `make_unique()` 来构建由 `unique_ptr` 所拥有的对象](#Rh-make_unique)
* [C.151: 用 `make_shared()` 来构建由 `shared_ptr` 所拥有的对象](#Rh-make_shared)
* [C.152: 禁止把指向派生类对象的数组的指针赋值给指向基类的指针](#Rh-array)
* [C.153: 优先采用虚函数而不是强制转换](#Rh-use-virtual)

### <a name="Rh-domain"></a>C.120: 使用类层次来表达具有天然层次化结构的概念

##### 理由

直接在代码中表达想法可以简化理解和维护工作。应当保证各个基类所表达的想法与全部派生类型精确匹配，并且确实找不到比使用继承所带来的紧耦合方式更好的表达方式。

当单纯使用数据成员就能搞定时请*不要*使用继承。这种情况通常意味着派生类型需要覆盖某个基类虚函数或者需要访问某个受保护成员。

##### 示例

    class DrawableUIElement {
    public:
        virtual void render() const = 0;
        // ...
    };
    
    class AbstractButton : public DrawableUIElement {
    public:
        virtual void onClick() = 0;
        // ...
    };
    
    class PushButton : public AbstractButton {
        void render() const override;
        void onClick() override;
        // ...
    };
    
    class Checkbox : public AbstractButton {
    // ...
    };

##### 示例，不好

请*不要*把非层次化的领域概念表示成类层次。

    template<typename T>
    class Container {
    public:
        // 列表操作：
        virtual T& get() = 0;
        virtual void put(T&) = 0;
        virtual void insert(Position) = 0;
        // ...
        // 向量操作：
        virtual T& operator[](int) = 0;
        virtual void sort() = 0;
        // ...
        // 树操作：
        virtual void balance() = 0;
        // ...
    };

大多数派生类都无法恰当实现这个接口所要求的大多数函数。
因而这个基类成为了一个实现负担。
此外，`Container` 的使用者无法依靠成员函数来相当高效地确实实施某个有意义的操作；
它可能会抛出某个异常。
因此使用者只得诉诸于运行时检查，并且
放弃使用这个（过于）一般化的接口，代之以某种运行时类型查询（比如 `dynamic_cast`）所确定的接口。

##### 强制实施

* 寻找带有许多不干别的只会抛出异常的成员的类。
* 对非公用基类 `B` 的每次使用进行标记，其中派生类 `D` 并未覆盖 `B` 的某个虚函数，或访问某个受保护成员，而 `B` 并非以下情况：为空，为 `D` 的模板参数或参数包组，或者为以 `D` 所特化的类模板。

### <a name="Rh-abstract"></a>C.121: 如果基类被用作接口的话，应使其成为纯抽象类

##### 理由

不包含数据的类更加稳定（更不脆弱易变）。
接口通常都应当全部由公开的纯虚函数和一个预置的或为空的虚析构函数组成。

##### 示例

    class My_interface {
    public:
        // ... 只有一个纯虚函数 ...
        virtual ~My_interface() {}   // 或者 =default
    };

##### 示例，不好

    class Goof {
    public:
        // ... 只有一个纯虚函数 ...
        // 没有虚析构函数
    };
    
    class Derived : public Goof {
        string s;
        // ...
    };
    
    void use()
    {
        unique_ptr<Goof> p {new Derived{"here we go"}};
        f(p.get()); // 通过 Goof 接口使用 Derived
        g(p.get()); // 通过 Goof 接口使用 Derived
    } // 泄漏

`Derived` 是通过其 `Goof` 接口而被 `delete` 的，而它的 `string` 则泄漏了。
为 `Goof` 提供虚析构函数就能使其都正常工作。


##### 强制实施

* 对任何含有数据成员同时带有并非从基类继承的可被覆盖（非 `final`）的虚函数的类给出警告。

### <a name="Rh-separation"></a>C.122: 当需要完全区分接口和实现时，应当用抽象类作为接口

##### 理由

诸如在 ABI（连接）边界这种地方。

##### 示例

    struct Device {
        virtual ~Device() = default;
        virtual void write(span<const char> outbuf) = 0;
        virtual void read(span<char> inbuf) = 0;
    };
    
    class D1 : public Device {
        // ... 数据 ...
    
        void write(span<const char> outbuf) override;
        void read(span<char> inbuf) override;
    };
    
    class D2 : public Device {
        // ... 不同的数据 ...
    
        void write(span<const char> outbuf) override;
        void read(span<char> inbuf) override;
    };

使用者可以通过由 `Device` 所提供的接口来互换地使用 `D1` 和 `D2`。
而且，只要其访问一直是通过 `Device` 进行的话，也可以以与老版本二进制不兼容的方式来更新 `D1` 和 `D2`。

##### 强制实施

    ???

## C.hierclass: 类层次的设计：

### <a name="Rh-abstract-ctor"></a>C.126: 抽象类通常并不需要构造函数

##### 理由

通常抽象类并没有任何需要由构造函数来初始化的对象。

##### 示例

    ???

##### 例外

* 有任务的基类构造函数，比如把对象注册到什么地方的时候，可能是需要构造函数的。
* 在极端少见的情况下，你可能发觉让抽象类来包含一点所有派生类都会共享的数据是有意义的
  （比如说，使用情况统计数据，调试信息等）；这样的类倾向于带有构造函数。但应当警醒的是：这样的类也倾向于要求进行虚继承。

##### 强制实施

对带有构造函数的抽象类进行标记。

### <a name="Rh-dtor"></a>C.127: 带有虚函数的类应当带有虚的或受保护的析构函数

##### 理由

带有虚函数的类通常是通过指向基类的指针来使用的。一般来说，最后一个使用者必须在基类指针上执行 `delete`，这常常是通过基类智能指针来做到的，因而析构函数应当为 `public` 和 `virtual`。而不那么常见的情况是当并不打算支持通过基类指针来删除时，这时析构函数应当为 `protected` 和非 `virtual`；参见 [C.35](#Rc-dtor-virtual)。

##### 示例，不好

    struct B {
        virtual int f() = 0;
        // ... 没有用户编写的析构函数，缺省为 public 非 virtual ...
    };
    
    // 不好：继承于没有虚析构函数的类
    struct D : B {
        string s {"default"};
    };
    
    void use()
    {
        unique_ptr<B> p = make_unique<D>();
        // ...
    } // 未定义行为。可能仅仅调用了 B::~B 而字符串则被泄漏了

##### 注解

有些人不遵守本条规则，因为他们打算仅通过 `shared_ptr` 来使用这些类：`std::shared_ptr<B> p = std::make_shared<D>(args);` 这种情况下，由共享指针来负责删除对象，因此并不会发生不适当的基类 `delete` 所导致的泄漏。坚持一贯这样做的人可能会得到假阳性的警告，但这条规则其实很重要——当通过 `make_unique` 分配对象时会如何呢？这样的话是不安全的，除非 `B` 的作者保证它不会被误用，比如可以让所有的构造函数为私有的并提供一个工厂函数，来强制保证分配都是通过 `make_shared` 进行。

##### 强制实施

* 带有任何虚函数的类的析构函数应当要么是 `public` 和 `virtual`，要么是 `protected` 和非 `virtual` 的。
* 把对带有虚函数但没有虚析构函数的类的 `delete` 标记出来。

### <a name="Rh-override"></a>C.128: 虚函数应当指明 `virtual`、`override`、`final` 三者之一

##### 理由

可读性。
检测错误。
明确写下的 `virtual`、`override` 或 `final` 是自说明的，并使编译器可以检查到基类和派生类之间的类型和/或名字的不匹配。不过写出超过一个则不仅多余而且是潜在的错误来源。

可以遵循简单明确的含义：

* `virtual` 刚好仅仅表明"这是一个新的虚函数"。
* `override` 刚好仅仅表明"这是一个非最终覆盖函数"。
* `final` 刚好仅仅表明"这是一个最终覆盖函数"。

##### 示例，不好

    struct B {
        void f1(int);
        virtual void f2(int) const;
        virtual void f3(int);
        // ...
    };
    
    struct D : B {
        void f1(int);        // 不好（希望会有警告）: D::f1() 隐藏了 B::f1()
        void f2(int) const;  // 不好（但惯用且合法）: 没有明确 override
        void f3(double);     // 不好（希望会有警告）: D::f3() 隐藏了 B::f3()
        // ...
    };

##### 示例，好

    struct Better : B {
        void f1(int) override;        // 错误（被发现）: Better::f1() 隐藏了 B::f1()
        void f2(int) const override;
        void f3(double) override;     // 错误（被发现）: Better::f3() 隐藏了 B::f3()
        // ...
    };

#### 讨论

我们希望消除两种特定类型的错误：

* **隐式虚函数**: 程序员有意使函数隐含为虚函数，而它确实如此（但代码的读者搞不清楚这点）；或者，程序员有意使函数隐含为虚函数，但它并非如此（例如，由于微妙的参数列表不匹配所导致）；或者，程序员并非有意使函数为虚函数，但它却成为虚函数（由于它刚好与基类中的某个虚函数具有相同的签名）
* **隐式覆盖**: 程序员有意使函数隐式地成为覆盖函数，而它确实如此（但代码的读者搞不清楚这点）；或者，程序员有意使函数隐式地成为覆盖函数，但它并非如此（例如，由于微妙的参数列表不匹配）；或者，程序员并非有意使函数成为覆盖函数，但它却成为覆盖函数（由于它刚好与基类中的某个虚函数具有相同的签名 -- 注意无论这个函数是否被显式声明为虚函数都会发生这个问题，因为程序员的意图既可能是要创建一个新的虚函数也可能要创建一个新的非虚函数）

##### 强制实施

* 比较基类和派生类中的虚函数的名字，并对并未进行覆盖的相同名字的使用进行标记。
* 对既没有 `override` 也没有 `final` 的覆盖函数进行标记。
* 对函数声明中使用 `virtual`、`override` 和 `final` 中超过一个的情况进行标记。

### <a name="Rh-kind"></a>C.129: 当设计类层次时，应区分实现继承和接口继承

##### 理由

接口中的实现细节会使接口变得脆弱；
就是说，当实现被改变时其用户不得不进行重新编译。
基类中的数据增加了基类实现的复杂性，而且会导致代码的重复。

##### 注解

定义：

* 接口继承，是使用继承来把用户和实现进行分离，
特别是允许添加和修改派生类而不影响基类的用户。
* 实现继承，是使用继承来简化新设施的实现，
通过将有用的操作提供给相关的新操作的实现者（有时候称作"差异式编程"）。

纯粹的接口类只是一组纯虚函数；参见 [I.25](#Ri-abstract)。

在早期的 OOP 时代（比如 80 和 90 年代），实现继承和接口继承通常是混在一起的，
而不良习惯则很难改掉。
即便是现在，这种混合在旧代码和老式的教学材料中也不少见。

对两种继承进行区分的重要性随着以下情形而增长：

* 类层次的大小（比如几十个派生类），
* 类层次的使用时期（比如几十年），以及
* 使用这个类层次的独立团体的数量
（比如，可能对分发和更新某个基类造成困难）


##### 示例，不好

    class Shape {   // 不好，混合了接口和实现
    public:
        Shape();
        Shape(Point ce = {0, 0}, Color co = none): cent{ce}, col {co} { /* ... */}
    
        Point center() const { return cent; }
        Color color() const { return col; }
    
        virtual void rotate(int) = 0;
        virtual void move(Point p) { cent = p; redraw(); }
    
        virtual void redraw();
    
        // ...
    private:
        Point cent;
        Color col;
    };
    
    class Circle : public Shape {
    public:
        Circle(Point c, int r) :Shape{c}, rad{r} { /* ... */ }
    
        // ...
    private:
        int rad;
    };
    
    class Triangle : public Shape {
    public:
        Triangle(Point p1, Point p2, Point p3); // 计算中心点
        // ...
    };

问题：

* 随着类层次的增长和向 `Shape` 添加更多的数据，构造函数会越发难于编写和维护。
* 为什么要计算 `Triangle` 的中心点？我们从不用它。
* 向 `Shape` 添加新的数据成员（比如绘制风格或者画布）
将导致所有派生于 `Shape` 的类和所有使用 `Shape` 的代码都需要进行复审，可能需要修改，而且很可能需要重新编译。

`Shape::move()` 的实现就是实现继承的一个例子：
我们为所有派生类一次性定义 `move()`。
在这种基类成员函数实现中的代码越多，在基类中放入的共享数据越多，
就能获得越多的好处——而类层次则越不稳定。

##### 示例

这个 `Shape` 类层次可以用接口继承重新编写：

    class Shape {  // 纯接口
    public:
        virtual Point center() const = 0;
        virtual Color color() const = 0;
    
        virtual void rotate(int) = 0;
        virtual void move(Point p) = 0;
    
        virtual void redraw() = 0;
    
        // ...
    };

注意纯接口很少会有构造函数：没什么需要构造的。

    class Circle : public Shape {
    public:
        Circle(Point c, int r, Color c) :cent{c}, rad{r}, col{c} { /* ... */ }
    
        Point center() const override { return cent; }
        Color color() const override { return col; }
    
        // ...
    private:
        Point cent;
        int rad;
        Color col;
    };

接口不再那么脆弱了，但成员函数的实现需要做更多工作。
比如说，每个派生于 `Shape` 的类都得实现 `center`。

##### 示例，双类层次

如何才能同时获得接口继承的稳定类层次的好处和实现继承的实现重用的好处呢？
一种流行的技巧是双类层次。
有许多实现双类层次的方式；这里，我们使用一种多重继承形式。

首先规划一个接口类的层次：

    class Shape {   // 纯接口
    public:
        virtual Point center() const = 0;
        virtual Color color() const = 0;
    
        virtual void rotate(int) = 0;
        virtual void move(Point p) = 0;
    
        virtual void redraw() = 0;
    
        // ...
    };
    
    class Circle : public virtual Shape {   // 纯接口
    public:
        virtual int radius() = 0;
        // ...
    };

为使这个接口有用处，我们必须提供其实现类（我们这里用相同的名字，但放入 `Impl` 命名空间）：

    class Impl::Shape : public virtual ::Shape { // 实现
    public:
        // 构造函数，析构函数
        // ...
        Point center() const override { /* ... */ }
        Color color() const override { /* ... */ }
    
        void rotate(int) override { /* ... */ }
        void move(Point p) override { /* ... */ }
    
        void redraw() override { /* ... */ }
    
        // ...
    };

现在 `Shape` 是一个贫乏的具有一个实现的类的例子，
但还请谅解，因为这只是用来展现一种针对更复杂的类层次的技巧的简单例子。

    class Impl::Circle : public virtual ::Circle, public Impl::Shape {   // 实现
    public:
        // 构造函数，析构函数
    
        int radius() override { /* ... */ }
        // ...
    };

我们可以通过添加一个 `Smiley` 类来扩展它（:-)）：

    class Smiley : public virtual Circle { // 纯接口
    public:
        // ...
    };
    
    class Impl::Smiley : public virtual ::Smiley, public Impl::Circle {   // 实现
    public:
        // 构造函数，析构函数
        // ...
    }

这里有两个类层次：

* 接口：Smiley -> Circle -> Shape
* 实现：Impl::Smiley -> Impl::Circle -> Impl::Shape

由于每个实现都同时派生于其接口和其实现基类，我们因此获得了一个晶格（DAG）：

    Smiley     ->         Circle     ->  Shape
      ^                     ^               ^
      |                     |               |
    Impl::Smiley -> Impl::Circle -> Impl::Shape

我们曾经说过，这只是用来构造双类层次的一种方式。

可以直接使用实现类层次，而不用通过抽象接口来进行。

    void work_with_shape(Shape&);
    
    int user()
    {
        Impl::Smiley my_smiley{ /* args */ };   // 创建具体的形状
        // ...
        my_smiley.some_member();        // 直接使用实现类
        // ...
        work_with_shape(my_smiley);     // 通过抽象接口使用实现
        // ...
    }

这种做法在实现类带有并未由抽象接口提供的成员时，
或者当直接使用某个成员具有优化机会（比如当实现成员函数为 `final`）时，比较有用。

##### 注解

分离接口和实现的另一个（相关的）技巧是 [Pimpl](#Ri-pimpl)。

##### 注解

在提供公共的功能时，我们通常需要在作为（有实现的）基类函数和（在某个实现命名空间中的）
自由函数之间进行选择。
基类能够提供更简短的写法，以及更容易访问（基类中的）共享数据，
但所付出的是其功能将仅能被这个类层次的用户所使用。

##### 强制实施

* 若派生类向基类转换的基类同时具有数据和虚函数，则对其进行标记
（但排除在派生类成员中对基类成员的调用）。
* ???


### <a name="Rh-copy"></a>C.130: 多态类的深拷贝；优先采用虚函数 `clone` 来替代复制构造/赋值

##### 理由

由于切片的问题，不鼓励多态类的复制操作，参见 [C.67](#Rc-copy-virtual)。如果确实需要复制语义的话，应当进行深复制：提供一个虚 `clone` 函数，它复制的是真正的最终派生类型，并返回指向新对象的具有所有权的指针，而且在派生类中它返回的也是派生类型（利用协变返回类型）。

##### 示例

    class B {
    public:
        virtual owner<B*> clone() = 0;
        virtual ~B() = default;
    
        B(const B&) = delete;
        B& operator=(const B&) = delete;
    };
    
    class D : public B {
    public:
        owner<D*> clone() override;
        ~D() override;
    };

通常来说，推荐使用智能指针来表示所有权（参见 [R.20](#Rr-owner)）。不过根据语言规则，协变返回类型不能是智能指针：当 `B::clone` 返回 `unique_ptr<B>` 时 `D::clone` 不能返回 `unique_ptr<D>`。因此，你得在所有覆盖函数中统一都返回 `unique_ptr<B>`，或者也可以使用[指导方针支持库](#SS-views)中的 `owner<>` 工具类。



### <a name="Rh-get"></a>C.131: 避免无价值的取值和设值函数

##### 理由

无价值的取值和设值函数没有提供语义价值；让数据项自己 `public` 是一样的。

##### 示例

    class Point {   // 不好：啰嗦
        int x;
        int y;
    public:
        Point(int xx, int yy) : x{xx}, y{yy} { }
        int get_x() const { return x; }
        void set_x(int xx) { x = xx; }
        int get_y() const { return y; }
        void set_y(int yy) { y = yy; }
        // 没有有行为的成员函数
    };

应当考虑把这个类变为 `struct`——就是一组没有行为的变量，全部都是公开数据而没有成员函数。

    struct Point {
        int x {0};
        int y {0};
    };

注意，我们可以为成员变量提供默认初始化式：[C.49: 优先进行初始化而不是在构造函数中赋值](#Rc-initialize).

##### 注解

这条规则的关键在于取值和设值函数的语义是否是平凡的。虽然并非是对"平凡"的完整定义，但我们考虑在取值/设值函数，以及当使用公开数据成员之间除了语法上的差别之外是否存在什么差别。非平凡的语义的例子可能有：维护类的不变式，或者在某种内部类型和接口类型之间进行的转换。

##### 强制实施

对大量仅提供单纯的成员访问而没有其他语义的 `get` 和 `set` 成员函数进行标记。

### <a name="Rh-virtual"></a>C.132: 请勿无理由地使函数 `virtual`

##### 理由

多余的 `virtual` 会增加运行时间和对象代码的大小。
虚函数可以被覆盖，因此派生类中可能因此发生错误。
虚函数保证会在模板化的层次中造成代码重复。

##### 示例，不好

    template<class T>
    class Vector {
    public:
        // ...
        virtual int size() const { return sz; }   // 不好：派生类能得到什么好处？
    private:
        T* elem;   // 元素
        int sz;    // 元素的数量
    };

这种类型的"向量"并非是为了让人用作基类的。

##### 强制实施

* 对带有虚函数但没有派生类的类进行标记。
* 对所有成员函数都为虚函数并带有实现的类进行标记。

### <a name="Rh-protected"></a>C.133: 避免 `protected` 数据

##### 理由

`protected` 数据是复杂性和错误的一种来源。
`protected` 数据会把不变式的陈述搞复杂。
`protected` 数据天生违反了避免把数据放入基类的指导原则，而这样通常还会导致不得不采用虚继承。

##### 示例，不好

    class Shape {
    public:
        // ... 接口函数 ...
    protected:
        // 为派生类所使用的数据：
        Color fill_color;
        Color edge_color;
        Style st;
    };

这样，由每个所定义的 `Shape` 来保证对受保护数据正确进行操作。
这样做一度很流行，但同样是维护性问题的一种主要来源。
在大型的类层次中，很难保持对受保护数据的一致性使用，因为代码可能有很多，
分散于大量的类之中。
能够触碰这些数据的类的集合是开放的：任何人都可以派生一个新的类并开始操作这些受保护数据。
检查这些类的完整集合通常是不可能做到的，因此对类的表示进行任何改动都是不可行的。
这些受保护数据上并没有强加的不变式；它们更像是一组全局变量。
受保护数据在大块代码中事实上成为了全局变量。

##### 注解

受保护数据经常看起来倾向于允许通过派生来进行任意的改进。
而通常你得到的是肆无忌惮的改动和各种错误。
应当[优先采用 `private` 数据](#Rc-private)并提供良好定义并强加的不变式。
或者通常更好的做法是，[不要在用作接口的任何类中存放数据](#Rh-abstract)。

##### 注解

受保护的成员函数则没有问题。

##### 强制实施

对带有 `protected` 数据的类进行标记。

### <a name="Rh-public"></a>C.134: 确保所有非 `const` 数据成员有相同的访问级别

##### 理由

防止出现会导致错误的逻辑混乱。
当非 `const` 数据成员的访问级别不同时，这个类型就会在它应当做什么上出现混乱。
这个类型是用来维持某个不变式的类型，还是仅仅集合了一组值而已？

##### 探讨

其核心问题是：哪段代码应当负责为变量维护有意义/正确的值？

确切地说存在两种数据成员：

* A: 不参与对象的不变式的数据成员。这些成员的任何值的互相组合都是有效的。
* B: 参与对象不变式的数据成员。并非每种值组合都是有意义的（否则就没有不变式了）。因此所有具有对这些变量的写访问权限的代码都应当了解这个不变式，了解其语义，并了解（而且积极实现并加强）用以维持值的正确性的规则。

A 类别中的数据成员就应当是 `public`（或者很少情况下，当你只想在派生类中见到它们时为 `protected`）。不需要对它们进行封装。系统中的所有代码都可以见到并操控它们。

B 类别中的数据成员应当为 `private` 或 `const`。这是因为封装很重要。让它们非 `private` 且非 `const` 可能意味着对象无法控制自身的状态：这个类以外的无限量的代码可能都需要了解这个不变式，并精确地参与它的维护工作——当这些数据成员都是 `public` 时，这可能包括使用这个对象的所有调用方代码；而当它们为 `protected` 时，这可能包括当前以及未来的派生类的所有代码�