## 第1章、算法概述

### 1.1 算法复杂度

时间复杂度按照从低到高的顺序，包括O(1)、O(logn)、O(n)、O(nlogn)、O(n2)等。

空间复杂度按照从低到高的顺序，包括O(1)、O(n)、O(n2)等。其中递归算法的空间复杂度和递归深度成正比。

## 第2章、数据结构基础

### 2.1	数组

随机访问；插入、删除元素都会导致大量元素被迫移动，影响效率。

### 2.2	链表

链表（linked list）是一种在物理上非连续、非顺序的数据结构，由若干节点（node）所组成。

![image-20200804142433509](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804142433509.png)

![image-20200804142539340](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804142539340.png)

**查找节点**，只能从头节点开始向逐节点查找。

![image-20200804142818523](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804142818523.png)

**更新节点**

![image-20200804143744476](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804143744476.png)

**插入节点**

尾插

![image-20200804143859981](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804143859981.png)

头插

![image-20200804143932448](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804143932448.png)

中间

![image-20200804143950014](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804143950014.png)

删除元素

![image-20200804144113003](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804144113003.png)

![image-20200804144126162](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804144126162.png)

![image-20200804144136239](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804144136239.png)

![image-20200804144231040](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804144231040.png)

### 2.3	栈和队列

#### 2.3.1 栈

![image-20200804144547438](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804144547438.png)

![image-20200804144557968](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804144557968.png)

![image-20200804144618748](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804144618748.png)

![image-20200804144629267](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804144629267.png)

![image-20200804144648840](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804144648840.png)

![image-20200804144703029](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804144703029.png)

#### 2.3.2 队列

![image-20200804144845227](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804144845227.png)



![image-20200804144901993](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804144901993.png)

#### 2.3.3 循环队列

> **（队尾下标+1）%数组长度 = 队头下标**时，代表此**队列满**。队尾指针指向的位置永远空出1位，所以**队列最大容量比数组长度小1**。

```cpp
//入队
if((rear+1)%length == front){
	//" 队列已满！";
}
array[rear] = element;
rear = (rear+1) % length;

//出队
if(rear == front){
//" 队列已空！";
}
front = (front+1) % length;
```

### 2.4 散列表

> 也叫作哈希表（hash table），这种数据结构提供了键（Key）和值（Value）的映射关系。只要给出一个Key，就可以高效查找到它所匹配的Value，时间复杂度接近于O(1)。

**解决哈希冲突**的方法主要有两种，一种是开放寻址法，一种是链表法。

- 开放寻址法的原理很简单，当一个Key通过哈希函数获得对应的数组下标已被占用时，我们可以“另谋高就”，寻找下一个空档位置。
- 当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可。

![image-20200804145935170](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804145935170.png)

**扩容**

1．扩容，创建一个新的Entry空数组，长度是原数组的2倍。
2．重新Hash。

```cpp
HashMap.Size >= Capacity×LoadFactor
```

## 第3章、树

![image-20200804151344611](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804151344611.png)

![image-20200804151410453](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804151410453.png)



### 3.1二叉树

* **满二叉树**（下图左）：**除叶子节点外**的所有分支节点**都含有2个非空子节点**的二叉树
* **完全二叉树**（下图右）：**除了最后一层，其余层都是“满”的**，这样的二叉树是完全二叉树
* **二叉排序树**：根节点的值大于其左子树中任意一个节点的值,小于其右节点中任意一节点的值。

![](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/al-tree-1-1596610787075.png)

![image-20200804151957879](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804151957879.png)

### 3.2 二叉树定理

1）任意二叉树，**度数为2的节点个数等于叶节点数减1。**

> 当只有1个节点时，度为0。每派生出1度，就会多出1个节点。派生出的度和派生出的节点数一定相等。
>
> `节点总数 = 总度数 + 1`设度数为2的节点数为`X2`，度数为1的节点数为`X1`，度数为0的节点数为`X0`。可以得出如下关系式：
>
> `X2 + X1 + X0 = 2X2 + X1 + 1`，推出 `X2 = X0 - 1`

2）满二叉树定理：**非空满二叉树的叶节点数等于其分支节点数加1。**

> 对于只有1个节点的树，该定理成立。从这开始思考，每产生1个分支节点(度数为2)。叶子节点数也会加1。

3）**一颗非空二叉树空子树的数目等于其节点数目加1**。

> 考虑只有1个根节点的二叉树：它有2个空子树，1个节点，因此结论成立。从这里开始考虑，每产生1个节点。空子树便会先减1然后加2。







![image-20200804151555878](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804151555878.png)



![image-20200804151607529](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200804151607529.png)

- 父节点的下标是`parent`，那么它的**左孩子**节点下标就是`2×parent + 1`；**右孩子**节点下标就是`2×parent + 2`。
- 左孩子节点的下标是`leftChild`，那么它的父节点下标就是`（leftChild-1）/ 2`
- 显然，对于一个稀疏的二叉树来说，用数组表示法是非常浪费空间的。

### 3.3 二叉树遍历

* **前序**遍历：根->左->右

* **中序**遍历：左->根->右

* **后序**遍历：左->右->根

* **层次**遍历：按层次从左到右依次遍历每层中的结点。

* ```cpp
  //        3
  //       / \
  //     9    20
  //    / \   / \
  //   N   N 15  7
  //前序遍历序列{3,9,20,15,7}
  //中序遍历序列{9,3,15,20,7}
  //后续遍历序列{9,15,7,20,3}
  ```

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

#### 递归版

```cpp
void InOrder(TreeNode *node)；  //中序遍历
void PostOrder(TreeNode *node)；//后序遍历
void PreOrder(TreeNode *pRoot) //前遍历
{
    if (pRoot == nullptr)
        return;
    std::cout << pRoot->val << " ";
    PreorderTraverse(pRoot->left);
    PreorderTraverse(pRoot->right);
}
```

#### 迭代版

```cpp
//前序遍历
void preorderTraversalIteration(TreeNode *root)
{
    stack<TreeNode*> st;
    if(root)
        st.push(root);

    while(!st.empty()){
        TreeNode *nd = st.top();
        st.pop();

        cout << nd->val << " ";//操作当前节点

        if(nd->right)
            st.push(nd->right);
        if(nd->left)
            st.push(nd->left);
    }
}

//中序遍历：
void inorderTraversalIteration(TreeNode *root)
{
    stack<TreeNode*> st;

    TreeNode *curr = root;

    while(curr || !st.empty()){
        if(curr){
            st.push(curr);
            curr = curr->left;
        }
        else{
            curr = st.top();
            st.pop();

            cout << curr->val << " ";//操作当前节点

            curr = curr->right;
        }
    }
}

//后序遍历
void postorderTraversalIteration(TreeNode *root)
{
    stack<TreeNode*> st;
    TreeNode *pre;

    if(root)
        st.push(root);

    while(!st.empty()){
        TreeNode *nd = st.top();
        /*
         * 出栈条件：
         * 对于叶子节点：直接弹出
         * 对于非叶子节点：如果已经遍历过其左子节点或右子节点，则弹出
         */
        if((!nd->left && !nd->right) || (pre && (nd->left == pre || nd->right == pre))){
            st.pop();
            cout << nd->val <<" ";//操作当前节点
            pre = nd;
        }
        else{//说明是一个非叶子节点，并且还未访问其左右孩子
            if(nd->right)
                st.push(nd->right);
            if(nd->left)
                st.push(nd->left);
        }
    }
}
```

#### 更简单的非递归

```cpp
//更简单的非递归前序遍历       根，左，右 用栈（反序）
void preOrder(TreeNode *root, std::vector<int> &path)
{
    std::stack<std::pair<TreeNode *, bool> > tmpStack;
    bool isVisited = false;
    tmpStack.push(make_pair(root, isVisited));

    while(!tmpStack.empty())
    {
        root = tmpStack.top().first;
        isVisited = tmpStack.top().second;
        tmpStack.pop();
        if(root == nullptr)
            continue;
        if(isVisited)
        {
            path.push_back(root->val);
        }
        else//用栈（反序）
        {
//            //前序
//            tmpStack.push(make_pair(root->right, false));      //右
//            tmpStack.push(make_pair(root->left, false));       //左
//            tmpStack.push(make_pair(root, true));              //根

//            //中序
//            tmpStack.push(make_pair(root->right, false));      //右
//            tmpStack.push(make_pair(root, true));              //根
//            tmpStack.push(make_pair(root->left, false));       //左

            //后序
            tmpStack.push(make_pair(root, true));              //根
            tmpStack.push(make_pair(root->right, false));      //右
            tmpStack.push(make_pair(root->left, false));       //左
        }
    }
}

```

```cpp
void LevelOrder(TreeNode *T){
    std::queue<TreeNode*> tmpQueue;          
    if (T == nullptr){
        return;
    }
    tmpQueue.push(T);
    
    TreeNode *tmpNode = new TreeNode(-1);    
    while (!tmpQueue.empty()){
        tmpNode = tmpQueue.front();
        cout << tmpNode->val<<" ";//输出
        tmpQueue.pop();
        if (tmpNode->left){
            tmpQueue.push(tmpNode->left);
        }
        if (tmpNode->right){
            tmpQueue.push(tmpNode->right);
        }
    }
}
```

### 3.4 二叉堆

> **最大堆**的任何一个父节点的值，都大于或等于它左、右孩子节点的值。
>
> ```cpp
> 
> ```
>
> **插入节点**
>
> ```
> 
> ```
>
> ![image-20200805092723024](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200805092723024.png)

![image-20200805092732989](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200805092732989.png)

**删除节点**



![image-20200805092756132](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200805092756132.png)

![image-20200805092806462](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200805092806462.png)

![image-20200805092830468](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20200805092830468.png)

堆的插入操作是单一节点的“上浮”，堆的删除操作是单一节点的“下沉”，

这两个操作的平均交换次数都是堆高度的一半，所以时间复杂度是O(logn)。

但构建堆的时间复杂度却并不是O(nlogn)，而是O(n)。

假设父节点的下标是parent，那么它的左孩子下标就是2×parent+1；右孩子下标就是2×parent+2。

```cpp
void UpAdjust(){
    int childIndex = array.size() - 1;
    int parentIndex = (childIndex - 1) / 2;
    const int temp = array.back();
    while (childIndex > 0 && temp > array[parentIndex]){
        array[childIndex] = array[parentIndex];
        childIndex = parentIndex;
        parentIndex = (childIndex - 1) / 2;
    }
    array[childIndex] = temp;
}
void DownAdjust(){
    int parentIndex = 0;
    int childIndex = 2 * parentIndex + 1;
    const int temp = array.front();
    while (childIndex < array.size()){
        // 找到左右孩子中的最大值
        if (childIndex + 1 < array.size() && array[childIndex + 1] > array[childIndex]){
            ++childIndex;
        }
        if (temp >= array[childIndex]){
            break;
        }
        else{
            array[parentIndex] = array[childIndex];
            parentIndex = childIndex;
            childIndex  = 2 * parentIndex + 1;
        }
    }
    array[parentIndex] = temp;
}
```

```cpp
#include <iostream>
#include <algorithm>
#include <functional>
#include <vector>
int main()
{
    std::cout << "Max heap:\n";

    std::vector<int> v { 3, 2, 4, 1, 5, 9 };

    std::cout << "initially, v: ";
    for (auto i : v) std::cout << i << ' ';
    std::cout << '\n';

    std::make_heap(v.begin(), v.end(), std::less<int>{});
    std::cout << "make_heap, v: ";
    for (auto i : v) std::cout << i << ' ';
    std::cout << '\n';

    v.push_back(6);
    std::push_heap(v.begin(), v.end());

    std::cout << "push_heap, v: ";
    for (auto i : v) std::cout << i << ' ';
    std::cout << '\n';

    std::pop_heap(v.begin(), v.end());
    v.pop_back();

    std::cout << "pop_heap, v: ";
    for (auto i : v) std::cout << i << ' ';
    std::cout << '\n';

}
```

## 第4章、排序



